module.exports = {

"[project]/node_modules/jmespath/jmespath.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
(function(exports1) {
    "use strict";
    function isArray(obj) {
        if (obj !== null) {
            return Object.prototype.toString.call(obj) === "[object Array]";
        } else {
            return false;
        }
    }
    function isObject(obj) {
        if (obj !== null) {
            return Object.prototype.toString.call(obj) === "[object Object]";
        } else {
            return false;
        }
    }
    function strictDeepEqual(first, second) {
        // Check the scalar case first.
        if (first === second) {
            return true;
        }
        // Check if they are the same type.
        var firstType = Object.prototype.toString.call(first);
        if (firstType !== Object.prototype.toString.call(second)) {
            return false;
        }
        // We know that first and second have the same type so we can just check the
        // first type from now on.
        if (isArray(first) === true) {
            // Short circuit if they're not the same length;
            if (first.length !== second.length) {
                return false;
            }
            for(var i = 0; i < first.length; i++){
                if (strictDeepEqual(first[i], second[i]) === false) {
                    return false;
                }
            }
            return true;
        }
        if (isObject(first) === true) {
            // An object is equal if it has the same key/value pairs.
            var keysSeen = {};
            for(var key in first){
                if (hasOwnProperty.call(first, key)) {
                    if (strictDeepEqual(first[key], second[key]) === false) {
                        return false;
                    }
                    keysSeen[key] = true;
                }
            }
            // Now check that there aren't any keys in second that weren't
            // in first.
            for(var key2 in second){
                if (hasOwnProperty.call(second, key2)) {
                    if (keysSeen[key2] !== true) {
                        return false;
                    }
                }
            }
            return true;
        }
        return false;
    }
    function isFalse(obj) {
        // From the spec:
        // A false value corresponds to the following values:
        // Empty list
        // Empty object
        // Empty string
        // False boolean
        // null value
        // First check the scalar values.
        if (obj === "" || obj === false || obj === null) {
            return true;
        } else if (isArray(obj) && obj.length === 0) {
            // Check for an empty array.
            return true;
        } else if (isObject(obj)) {
            // Check for an empty object.
            for(var key in obj){
                // If there are any keys, then
                // the object is not empty so the object
                // is not false.
                if (obj.hasOwnProperty(key)) {
                    return false;
                }
            }
            return true;
        } else {
            return false;
        }
    }
    function objValues(obj) {
        var keys = Object.keys(obj);
        var values = [];
        for(var i = 0; i < keys.length; i++){
            values.push(obj[keys[i]]);
        }
        return values;
    }
    function merge(a, b) {
        var merged = {};
        for(var key in a){
            merged[key] = a[key];
        }
        for(var key2 in b){
            merged[key2] = b[key2];
        }
        return merged;
    }
    var trimLeft;
    if (typeof String.prototype.trimLeft === "function") {
        trimLeft = function(str) {
            return str.trimLeft();
        };
    } else {
        trimLeft = function(str) {
            return str.match(/^\s*(.*)/)[1];
        };
    }
    // Type constants used to define functions.
    var TYPE_NUMBER = 0;
    var TYPE_ANY = 1;
    var TYPE_STRING = 2;
    var TYPE_ARRAY = 3;
    var TYPE_OBJECT = 4;
    var TYPE_BOOLEAN = 5;
    var TYPE_EXPREF = 6;
    var TYPE_NULL = 7;
    var TYPE_ARRAY_NUMBER = 8;
    var TYPE_ARRAY_STRING = 9;
    var TYPE_NAME_TABLE = {
        0: 'number',
        1: 'any',
        2: 'string',
        3: 'array',
        4: 'object',
        5: 'boolean',
        6: 'expression',
        7: 'null',
        8: 'Array<number>',
        9: 'Array<string>'
    };
    var TOK_EOF = "EOF";
    var TOK_UNQUOTEDIDENTIFIER = "UnquotedIdentifier";
    var TOK_QUOTEDIDENTIFIER = "QuotedIdentifier";
    var TOK_RBRACKET = "Rbracket";
    var TOK_RPAREN = "Rparen";
    var TOK_COMMA = "Comma";
    var TOK_COLON = "Colon";
    var TOK_RBRACE = "Rbrace";
    var TOK_NUMBER = "Number";
    var TOK_CURRENT = "Current";
    var TOK_EXPREF = "Expref";
    var TOK_PIPE = "Pipe";
    var TOK_OR = "Or";
    var TOK_AND = "And";
    var TOK_EQ = "EQ";
    var TOK_GT = "GT";
    var TOK_LT = "LT";
    var TOK_GTE = "GTE";
    var TOK_LTE = "LTE";
    var TOK_NE = "NE";
    var TOK_FLATTEN = "Flatten";
    var TOK_STAR = "Star";
    var TOK_FILTER = "Filter";
    var TOK_DOT = "Dot";
    var TOK_NOT = "Not";
    var TOK_LBRACE = "Lbrace";
    var TOK_LBRACKET = "Lbracket";
    var TOK_LPAREN = "Lparen";
    var TOK_LITERAL = "Literal";
    // The "&", "[", "<", ">" tokens
    // are not in basicToken because
    // there are two token variants
    // ("&&", "[?", "<=", ">=").  This is specially handled
    // below.
    var basicTokens = {
        ".": TOK_DOT,
        "*": TOK_STAR,
        ",": TOK_COMMA,
        ":": TOK_COLON,
        "{": TOK_LBRACE,
        "}": TOK_RBRACE,
        "]": TOK_RBRACKET,
        "(": TOK_LPAREN,
        ")": TOK_RPAREN,
        "@": TOK_CURRENT
    };
    var operatorStartToken = {
        "<": true,
        ">": true,
        "=": true,
        "!": true
    };
    var skipChars = {
        " ": true,
        "\t": true,
        "\n": true
    };
    function isAlpha(ch) {
        return ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z" || ch === "_";
    }
    function isNum(ch) {
        return ch >= "0" && ch <= "9" || ch === "-";
    }
    function isAlphaNum(ch) {
        return ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z" || ch >= "0" && ch <= "9" || ch === "_";
    }
    function Lexer() {}
    Lexer.prototype = {
        tokenize: function(stream) {
            var tokens = [];
            this._current = 0;
            var start;
            var identifier;
            var token;
            while(this._current < stream.length){
                if (isAlpha(stream[this._current])) {
                    start = this._current;
                    identifier = this._consumeUnquotedIdentifier(stream);
                    tokens.push({
                        type: TOK_UNQUOTEDIDENTIFIER,
                        value: identifier,
                        start: start
                    });
                } else if (basicTokens[stream[this._current]] !== undefined) {
                    tokens.push({
                        type: basicTokens[stream[this._current]],
                        value: stream[this._current],
                        start: this._current
                    });
                    this._current++;
                } else if (isNum(stream[this._current])) {
                    token = this._consumeNumber(stream);
                    tokens.push(token);
                } else if (stream[this._current] === "[") {
                    // No need to increment this._current.  This happens
                    // in _consumeLBracket
                    token = this._consumeLBracket(stream);
                    tokens.push(token);
                } else if (stream[this._current] === "\"") {
                    start = this._current;
                    identifier = this._consumeQuotedIdentifier(stream);
                    tokens.push({
                        type: TOK_QUOTEDIDENTIFIER,
                        value: identifier,
                        start: start
                    });
                } else if (stream[this._current] === "'") {
                    start = this._current;
                    identifier = this._consumeRawStringLiteral(stream);
                    tokens.push({
                        type: TOK_LITERAL,
                        value: identifier,
                        start: start
                    });
                } else if (stream[this._current] === "`") {
                    start = this._current;
                    var literal = this._consumeLiteral(stream);
                    tokens.push({
                        type: TOK_LITERAL,
                        value: literal,
                        start: start
                    });
                } else if (operatorStartToken[stream[this._current]] !== undefined) {
                    tokens.push(this._consumeOperator(stream));
                } else if (skipChars[stream[this._current]] !== undefined) {
                    // Ignore whitespace.
                    this._current++;
                } else if (stream[this._current] === "&") {
                    start = this._current;
                    this._current++;
                    if (stream[this._current] === "&") {
                        this._current++;
                        tokens.push({
                            type: TOK_AND,
                            value: "&&",
                            start: start
                        });
                    } else {
                        tokens.push({
                            type: TOK_EXPREF,
                            value: "&",
                            start: start
                        });
                    }
                } else if (stream[this._current] === "|") {
                    start = this._current;
                    this._current++;
                    if (stream[this._current] === "|") {
                        this._current++;
                        tokens.push({
                            type: TOK_OR,
                            value: "||",
                            start: start
                        });
                    } else {
                        tokens.push({
                            type: TOK_PIPE,
                            value: "|",
                            start: start
                        });
                    }
                } else {
                    var error = new Error("Unknown character:" + stream[this._current]);
                    error.name = "LexerError";
                    throw error;
                }
            }
            return tokens;
        },
        _consumeUnquotedIdentifier: function(stream) {
            var start = this._current;
            this._current++;
            while(this._current < stream.length && isAlphaNum(stream[this._current])){
                this._current++;
            }
            return stream.slice(start, this._current);
        },
        _consumeQuotedIdentifier: function(stream) {
            var start = this._current;
            this._current++;
            var maxLength = stream.length;
            while(stream[this._current] !== "\"" && this._current < maxLength){
                // You can escape a double quote and you can escape an escape.
                var current = this._current;
                if (stream[current] === "\\" && (stream[current + 1] === "\\" || stream[current + 1] === "\"")) {
                    current += 2;
                } else {
                    current++;
                }
                this._current = current;
            }
            this._current++;
            return JSON.parse(stream.slice(start, this._current));
        },
        _consumeRawStringLiteral: function(stream) {
            var start = this._current;
            this._current++;
            var maxLength = stream.length;
            while(stream[this._current] !== "'" && this._current < maxLength){
                // You can escape a single quote and you can escape an escape.
                var current = this._current;
                if (stream[current] === "\\" && (stream[current + 1] === "\\" || stream[current + 1] === "'")) {
                    current += 2;
                } else {
                    current++;
                }
                this._current = current;
            }
            this._current++;
            var literal = stream.slice(start + 1, this._current - 1);
            return literal.replace("\\'", "'");
        },
        _consumeNumber: function(stream) {
            var start = this._current;
            this._current++;
            var maxLength = stream.length;
            while(isNum(stream[this._current]) && this._current < maxLength){
                this._current++;
            }
            var value = parseInt(stream.slice(start, this._current));
            return {
                type: TOK_NUMBER,
                value: value,
                start: start
            };
        },
        _consumeLBracket: function(stream) {
            var start = this._current;
            this._current++;
            if (stream[this._current] === "?") {
                this._current++;
                return {
                    type: TOK_FILTER,
                    value: "[?",
                    start: start
                };
            } else if (stream[this._current] === "]") {
                this._current++;
                return {
                    type: TOK_FLATTEN,
                    value: "[]",
                    start: start
                };
            } else {
                return {
                    type: TOK_LBRACKET,
                    value: "[",
                    start: start
                };
            }
        },
        _consumeOperator: function(stream) {
            var start = this._current;
            var startingChar = stream[start];
            this._current++;
            if (startingChar === "!") {
                if (stream[this._current] === "=") {
                    this._current++;
                    return {
                        type: TOK_NE,
                        value: "!=",
                        start: start
                    };
                } else {
                    return {
                        type: TOK_NOT,
                        value: "!",
                        start: start
                    };
                }
            } else if (startingChar === "<") {
                if (stream[this._current] === "=") {
                    this._current++;
                    return {
                        type: TOK_LTE,
                        value: "<=",
                        start: start
                    };
                } else {
                    return {
                        type: TOK_LT,
                        value: "<",
                        start: start
                    };
                }
            } else if (startingChar === ">") {
                if (stream[this._current] === "=") {
                    this._current++;
                    return {
                        type: TOK_GTE,
                        value: ">=",
                        start: start
                    };
                } else {
                    return {
                        type: TOK_GT,
                        value: ">",
                        start: start
                    };
                }
            } else if (startingChar === "=") {
                if (stream[this._current] === "=") {
                    this._current++;
                    return {
                        type: TOK_EQ,
                        value: "==",
                        start: start
                    };
                }
            }
        },
        _consumeLiteral: function(stream) {
            this._current++;
            var start = this._current;
            var maxLength = stream.length;
            var literal;
            while(stream[this._current] !== "`" && this._current < maxLength){
                // You can escape a literal char or you can escape the escape.
                var current = this._current;
                if (stream[current] === "\\" && (stream[current + 1] === "\\" || stream[current + 1] === "`")) {
                    current += 2;
                } else {
                    current++;
                }
                this._current = current;
            }
            var literalString = trimLeft(stream.slice(start, this._current));
            literalString = literalString.replace("\\`", "`");
            if (this._looksLikeJSON(literalString)) {
                literal = JSON.parse(literalString);
            } else {
                // Try to JSON parse it as "<literal>"
                literal = JSON.parse("\"" + literalString + "\"");
            }
            // +1 gets us to the ending "`", +1 to move on to the next char.
            this._current++;
            return literal;
        },
        _looksLikeJSON: function(literalString) {
            var startingChars = "[{\"";
            var jsonLiterals = [
                "true",
                "false",
                "null"
            ];
            var numberLooking = "-0123456789";
            if (literalString === "") {
                return false;
            } else if (startingChars.indexOf(literalString[0]) >= 0) {
                return true;
            } else if (jsonLiterals.indexOf(literalString) >= 0) {
                return true;
            } else if (numberLooking.indexOf(literalString[0]) >= 0) {
                try {
                    JSON.parse(literalString);
                    return true;
                } catch (ex) {
                    return false;
                }
            } else {
                return false;
            }
        }
    };
    var bindingPower = {};
    bindingPower[TOK_EOF] = 0;
    bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;
    bindingPower[TOK_QUOTEDIDENTIFIER] = 0;
    bindingPower[TOK_RBRACKET] = 0;
    bindingPower[TOK_RPAREN] = 0;
    bindingPower[TOK_COMMA] = 0;
    bindingPower[TOK_RBRACE] = 0;
    bindingPower[TOK_NUMBER] = 0;
    bindingPower[TOK_CURRENT] = 0;
    bindingPower[TOK_EXPREF] = 0;
    bindingPower[TOK_PIPE] = 1;
    bindingPower[TOK_OR] = 2;
    bindingPower[TOK_AND] = 3;
    bindingPower[TOK_EQ] = 5;
    bindingPower[TOK_GT] = 5;
    bindingPower[TOK_LT] = 5;
    bindingPower[TOK_GTE] = 5;
    bindingPower[TOK_LTE] = 5;
    bindingPower[TOK_NE] = 5;
    bindingPower[TOK_FLATTEN] = 9;
    bindingPower[TOK_STAR] = 20;
    bindingPower[TOK_FILTER] = 21;
    bindingPower[TOK_DOT] = 40;
    bindingPower[TOK_NOT] = 45;
    bindingPower[TOK_LBRACE] = 50;
    bindingPower[TOK_LBRACKET] = 55;
    bindingPower[TOK_LPAREN] = 60;
    function Parser() {}
    Parser.prototype = {
        parse: function(expression) {
            this._loadTokens(expression);
            this.index = 0;
            var ast = this.expression(0);
            if (this._lookahead(0) !== TOK_EOF) {
                var t = this._lookaheadToken(0);
                var error = new Error("Unexpected token type: " + t.type + ", value: " + t.value);
                error.name = "ParserError";
                throw error;
            }
            return ast;
        },
        _loadTokens: function(expression) {
            var lexer = new Lexer();
            var tokens = lexer.tokenize(expression);
            tokens.push({
                type: TOK_EOF,
                value: "",
                start: expression.length
            });
            this.tokens = tokens;
        },
        expression: function(rbp) {
            var leftToken = this._lookaheadToken(0);
            this._advance();
            var left = this.nud(leftToken);
            var currentToken = this._lookahead(0);
            while(rbp < bindingPower[currentToken]){
                this._advance();
                left = this.led(currentToken, left);
                currentToken = this._lookahead(0);
            }
            return left;
        },
        _lookahead: function(number) {
            return this.tokens[this.index + number].type;
        },
        _lookaheadToken: function(number) {
            return this.tokens[this.index + number];
        },
        _advance: function() {
            this.index++;
        },
        nud: function(token) {
            var left;
            var right;
            var expression;
            switch(token.type){
                case TOK_LITERAL:
                    return {
                        type: "Literal",
                        value: token.value
                    };
                case TOK_UNQUOTEDIDENTIFIER:
                    return {
                        type: "Field",
                        name: token.value
                    };
                case TOK_QUOTEDIDENTIFIER:
                    var node = {
                        type: "Field",
                        name: token.value
                    };
                    if (this._lookahead(0) === TOK_LPAREN) {
                        throw new Error("Quoted identifier not allowed for function names.");
                    }
                    return node;
                case TOK_NOT:
                    right = this.expression(bindingPower.Not);
                    return {
                        type: "NotExpression",
                        children: [
                            right
                        ]
                    };
                case TOK_STAR:
                    left = {
                        type: "Identity"
                    };
                    right = null;
                    if (this._lookahead(0) === TOK_RBRACKET) {
                        // This can happen in a multiselect,
                        // [a, b, *]
                        right = {
                            type: "Identity"
                        };
                    } else {
                        right = this._parseProjectionRHS(bindingPower.Star);
                    }
                    return {
                        type: "ValueProjection",
                        children: [
                            left,
                            right
                        ]
                    };
                case TOK_FILTER:
                    return this.led(token.type, {
                        type: "Identity"
                    });
                case TOK_LBRACE:
                    return this._parseMultiselectHash();
                case TOK_FLATTEN:
                    left = {
                        type: TOK_FLATTEN,
                        children: [
                            {
                                type: "Identity"
                            }
                        ]
                    };
                    right = this._parseProjectionRHS(bindingPower.Flatten);
                    return {
                        type: "Projection",
                        children: [
                            left,
                            right
                        ]
                    };
                case TOK_LBRACKET:
                    if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {
                        right = this._parseIndexExpression();
                        return this._projectIfSlice({
                            type: "Identity"
                        }, right);
                    } else if (this._lookahead(0) === TOK_STAR && this._lookahead(1) === TOK_RBRACKET) {
                        this._advance();
                        this._advance();
                        right = this._parseProjectionRHS(bindingPower.Star);
                        return {
                            type: "Projection",
                            children: [
                                {
                                    type: "Identity"
                                },
                                right
                            ]
                        };
                    }
                    return this._parseMultiselectList();
                case TOK_CURRENT:
                    return {
                        type: TOK_CURRENT
                    };
                case TOK_EXPREF:
                    expression = this.expression(bindingPower.Expref);
                    return {
                        type: "ExpressionReference",
                        children: [
                            expression
                        ]
                    };
                case TOK_LPAREN:
                    var args = [];
                    while(this._lookahead(0) !== TOK_RPAREN){
                        if (this._lookahead(0) === TOK_CURRENT) {
                            expression = {
                                type: TOK_CURRENT
                            };
                            this._advance();
                        } else {
                            expression = this.expression(0);
                        }
                        args.push(expression);
                    }
                    this._match(TOK_RPAREN);
                    return args[0];
                default:
                    this._errorToken(token);
            }
        },
        led: function(tokenName, left) {
            var right;
            switch(tokenName){
                case TOK_DOT:
                    var rbp = bindingPower.Dot;
                    if (this._lookahead(0) !== TOK_STAR) {
                        right = this._parseDotRHS(rbp);
                        return {
                            type: "Subexpression",
                            children: [
                                left,
                                right
                            ]
                        };
                    }
                    // Creating a projection.
                    this._advance();
                    right = this._parseProjectionRHS(rbp);
                    return {
                        type: "ValueProjection",
                        children: [
                            left,
                            right
                        ]
                    };
                case TOK_PIPE:
                    right = this.expression(bindingPower.Pipe);
                    return {
                        type: TOK_PIPE,
                        children: [
                            left,
                            right
                        ]
                    };
                case TOK_OR:
                    right = this.expression(bindingPower.Or);
                    return {
                        type: "OrExpression",
                        children: [
                            left,
                            right
                        ]
                    };
                case TOK_AND:
                    right = this.expression(bindingPower.And);
                    return {
                        type: "AndExpression",
                        children: [
                            left,
                            right
                        ]
                    };
                case TOK_LPAREN:
                    var name = left.name;
                    var args = [];
                    var expression, node;
                    while(this._lookahead(0) !== TOK_RPAREN){
                        if (this._lookahead(0) === TOK_CURRENT) {
                            expression = {
                                type: TOK_CURRENT
                            };
                            this._advance();
                        } else {
                            expression = this.expression(0);
                        }
                        if (this._lookahead(0) === TOK_COMMA) {
                            this._match(TOK_COMMA);
                        }
                        args.push(expression);
                    }
                    this._match(TOK_RPAREN);
                    node = {
                        type: "Function",
                        name: name,
                        children: args
                    };
                    return node;
                case TOK_FILTER:
                    var condition = this.expression(0);
                    this._match(TOK_RBRACKET);
                    if (this._lookahead(0) === TOK_FLATTEN) {
                        right = {
                            type: "Identity"
                        };
                    } else {
                        right = this._parseProjectionRHS(bindingPower.Filter);
                    }
                    return {
                        type: "FilterProjection",
                        children: [
                            left,
                            right,
                            condition
                        ]
                    };
                case TOK_FLATTEN:
                    var leftNode = {
                        type: TOK_FLATTEN,
                        children: [
                            left
                        ]
                    };
                    var rightNode = this._parseProjectionRHS(bindingPower.Flatten);
                    return {
                        type: "Projection",
                        children: [
                            leftNode,
                            rightNode
                        ]
                    };
                case TOK_EQ:
                case TOK_NE:
                case TOK_GT:
                case TOK_GTE:
                case TOK_LT:
                case TOK_LTE:
                    return this._parseComparator(left, tokenName);
                case TOK_LBRACKET:
                    var token = this._lookaheadToken(0);
                    if (token.type === TOK_NUMBER || token.type === TOK_COLON) {
                        right = this._parseIndexExpression();
                        return this._projectIfSlice(left, right);
                    }
                    this._match(TOK_STAR);
                    this._match(TOK_RBRACKET);
                    right = this._parseProjectionRHS(bindingPower.Star);
                    return {
                        type: "Projection",
                        children: [
                            left,
                            right
                        ]
                    };
                default:
                    this._errorToken(this._lookaheadToken(0));
            }
        },
        _match: function(tokenType) {
            if (this._lookahead(0) === tokenType) {
                this._advance();
            } else {
                var t = this._lookaheadToken(0);
                var error = new Error("Expected " + tokenType + ", got: " + t.type);
                error.name = "ParserError";
                throw error;
            }
        },
        _errorToken: function(token) {
            var error = new Error("Invalid token (" + token.type + "): \"" + token.value + "\"");
            error.name = "ParserError";
            throw error;
        },
        _parseIndexExpression: function() {
            if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {
                return this._parseSliceExpression();
            } else {
                var node = {
                    type: "Index",
                    value: this._lookaheadToken(0).value
                };
                this._advance();
                this._match(TOK_RBRACKET);
                return node;
            }
        },
        _projectIfSlice: function(left, right) {
            var indexExpr = {
                type: "IndexExpression",
                children: [
                    left,
                    right
                ]
            };
            if (right.type === "Slice") {
                return {
                    type: "Projection",
                    children: [
                        indexExpr,
                        this._parseProjectionRHS(bindingPower.Star)
                    ]
                };
            } else {
                return indexExpr;
            }
        },
        _parseSliceExpression: function() {
            // [start:end:step] where each part is optional, as well as the last
            // colon.
            var parts = [
                null,
                null,
                null
            ];
            var index = 0;
            var currentToken = this._lookahead(0);
            while(currentToken !== TOK_RBRACKET && index < 3){
                if (currentToken === TOK_COLON) {
                    index++;
                    this._advance();
                } else if (currentToken === TOK_NUMBER) {
                    parts[index] = this._lookaheadToken(0).value;
                    this._advance();
                } else {
                    var t = this._lookahead(0);
                    var error = new Error("Syntax error, unexpected token: " + t.value + "(" + t.type + ")");
                    error.name = "Parsererror";
                    throw error;
                }
                currentToken = this._lookahead(0);
            }
            this._match(TOK_RBRACKET);
            return {
                type: "Slice",
                children: parts
            };
        },
        _parseComparator: function(left, comparator) {
            var right = this.expression(bindingPower[comparator]);
            return {
                type: "Comparator",
                name: comparator,
                children: [
                    left,
                    right
                ]
            };
        },
        _parseDotRHS: function(rbp) {
            var lookahead = this._lookahead(0);
            var exprTokens = [
                TOK_UNQUOTEDIDENTIFIER,
                TOK_QUOTEDIDENTIFIER,
                TOK_STAR
            ];
            if (exprTokens.indexOf(lookahead) >= 0) {
                return this.expression(rbp);
            } else if (lookahead === TOK_LBRACKET) {
                this._match(TOK_LBRACKET);
                return this._parseMultiselectList();
            } else if (lookahead === TOK_LBRACE) {
                this._match(TOK_LBRACE);
                return this._parseMultiselectHash();
            }
        },
        _parseProjectionRHS: function(rbp) {
            var right;
            if (bindingPower[this._lookahead(0)] < 10) {
                right = {
                    type: "Identity"
                };
            } else if (this._lookahead(0) === TOK_LBRACKET) {
                right = this.expression(rbp);
            } else if (this._lookahead(0) === TOK_FILTER) {
                right = this.expression(rbp);
            } else if (this._lookahead(0) === TOK_DOT) {
                this._match(TOK_DOT);
                right = this._parseDotRHS(rbp);
            } else {
                var t = this._lookaheadToken(0);
                var error = new Error("Sytanx error, unexpected token: " + t.value + "(" + t.type + ")");
                error.name = "ParserError";
                throw error;
            }
            return right;
        },
        _parseMultiselectList: function() {
            var expressions = [];
            while(this._lookahead(0) !== TOK_RBRACKET){
                var expression = this.expression(0);
                expressions.push(expression);
                if (this._lookahead(0) === TOK_COMMA) {
                    this._match(TOK_COMMA);
                    if (this._lookahead(0) === TOK_RBRACKET) {
                        throw new Error("Unexpected token Rbracket");
                    }
                }
            }
            this._match(TOK_RBRACKET);
            return {
                type: "MultiSelectList",
                children: expressions
            };
        },
        _parseMultiselectHash: function() {
            var pairs = [];
            var identifierTypes = [
                TOK_UNQUOTEDIDENTIFIER,
                TOK_QUOTEDIDENTIFIER
            ];
            var keyToken, keyName, value, node;
            for(;;){
                keyToken = this._lookaheadToken(0);
                if (identifierTypes.indexOf(keyToken.type) < 0) {
                    throw new Error("Expecting an identifier token, got: " + keyToken.type);
                }
                keyName = keyToken.value;
                this._advance();
                this._match(TOK_COLON);
                value = this.expression(0);
                node = {
                    type: "KeyValuePair",
                    name: keyName,
                    value: value
                };
                pairs.push(node);
                if (this._lookahead(0) === TOK_COMMA) {
                    this._match(TOK_COMMA);
                } else if (this._lookahead(0) === TOK_RBRACE) {
                    this._match(TOK_RBRACE);
                    break;
                }
            }
            return {
                type: "MultiSelectHash",
                children: pairs
            };
        }
    };
    function TreeInterpreter(runtime) {
        this.runtime = runtime;
    }
    TreeInterpreter.prototype = {
        search: function(node, value) {
            return this.visit(node, value);
        },
        visit: function(node, value) {
            var matched, current, result, first, second, field, left, right, collected, i;
            switch(node.type){
                case "Field":
                    if (value !== null && isObject(value)) {
                        field = value[node.name];
                        if (field === undefined) {
                            return null;
                        } else {
                            return field;
                        }
                    }
                    return null;
                case "Subexpression":
                    result = this.visit(node.children[0], value);
                    for(i = 1; i < node.children.length; i++){
                        result = this.visit(node.children[1], result);
                        if (result === null) {
                            return null;
                        }
                    }
                    return result;
                case "IndexExpression":
                    left = this.visit(node.children[0], value);
                    right = this.visit(node.children[1], left);
                    return right;
                case "Index":
                    if (!isArray(value)) {
                        return null;
                    }
                    var index = node.value;
                    if (index < 0) {
                        index = value.length + index;
                    }
                    result = value[index];
                    if (result === undefined) {
                        result = null;
                    }
                    return result;
                case "Slice":
                    if (!isArray(value)) {
                        return null;
                    }
                    var sliceParams = node.children.slice(0);
                    var computed = this.computeSliceParams(value.length, sliceParams);
                    var start = computed[0];
                    var stop = computed[1];
                    var step = computed[2];
                    result = [];
                    if (step > 0) {
                        for(i = start; i < stop; i += step){
                            result.push(value[i]);
                        }
                    } else {
                        for(i = start; i > stop; i += step){
                            result.push(value[i]);
                        }
                    }
                    return result;
                case "Projection":
                    // Evaluate left child.
                    var base = this.visit(node.children[0], value);
                    if (!isArray(base)) {
                        return null;
                    }
                    collected = [];
                    for(i = 0; i < base.length; i++){
                        current = this.visit(node.children[1], base[i]);
                        if (current !== null) {
                            collected.push(current);
                        }
                    }
                    return collected;
                case "ValueProjection":
                    // Evaluate left child.
                    base = this.visit(node.children[0], value);
                    if (!isObject(base)) {
                        return null;
                    }
                    collected = [];
                    var values = objValues(base);
                    for(i = 0; i < values.length; i++){
                        current = this.visit(node.children[1], values[i]);
                        if (current !== null) {
                            collected.push(current);
                        }
                    }
                    return collected;
                case "FilterProjection":
                    base = this.visit(node.children[0], value);
                    if (!isArray(base)) {
                        return null;
                    }
                    var filtered = [];
                    var finalResults = [];
                    for(i = 0; i < base.length; i++){
                        matched = this.visit(node.children[2], base[i]);
                        if (!isFalse(matched)) {
                            filtered.push(base[i]);
                        }
                    }
                    for(var j = 0; j < filtered.length; j++){
                        current = this.visit(node.children[1], filtered[j]);
                        if (current !== null) {
                            finalResults.push(current);
                        }
                    }
                    return finalResults;
                case "Comparator":
                    first = this.visit(node.children[0], value);
                    second = this.visit(node.children[1], value);
                    switch(node.name){
                        case TOK_EQ:
                            result = strictDeepEqual(first, second);
                            break;
                        case TOK_NE:
                            result = !strictDeepEqual(first, second);
                            break;
                        case TOK_GT:
                            result = first > second;
                            break;
                        case TOK_GTE:
                            result = first >= second;
                            break;
                        case TOK_LT:
                            result = first < second;
                            break;
                        case TOK_LTE:
                            result = first <= second;
                            break;
                        default:
                            throw new Error("Unknown comparator: " + node.name);
                    }
                    return result;
                case TOK_FLATTEN:
                    var original = this.visit(node.children[0], value);
                    if (!isArray(original)) {
                        return null;
                    }
                    var merged = [];
                    for(i = 0; i < original.length; i++){
                        current = original[i];
                        if (isArray(current)) {
                            merged.push.apply(merged, current);
                        } else {
                            merged.push(current);
                        }
                    }
                    return merged;
                case "Identity":
                    return value;
                case "MultiSelectList":
                    if (value === null) {
                        return null;
                    }
                    collected = [];
                    for(i = 0; i < node.children.length; i++){
                        collected.push(this.visit(node.children[i], value));
                    }
                    return collected;
                case "MultiSelectHash":
                    if (value === null) {
                        return null;
                    }
                    collected = {};
                    var child;
                    for(i = 0; i < node.children.length; i++){
                        child = node.children[i];
                        collected[child.name] = this.visit(child.value, value);
                    }
                    return collected;
                case "OrExpression":
                    matched = this.visit(node.children[0], value);
                    if (isFalse(matched)) {
                        matched = this.visit(node.children[1], value);
                    }
                    return matched;
                case "AndExpression":
                    first = this.visit(node.children[0], value);
                    if (isFalse(first) === true) {
                        return first;
                    }
                    return this.visit(node.children[1], value);
                case "NotExpression":
                    first = this.visit(node.children[0], value);
                    return isFalse(first);
                case "Literal":
                    return node.value;
                case TOK_PIPE:
                    left = this.visit(node.children[0], value);
                    return this.visit(node.children[1], left);
                case TOK_CURRENT:
                    return value;
                case "Function":
                    var resolvedArgs = [];
                    for(i = 0; i < node.children.length; i++){
                        resolvedArgs.push(this.visit(node.children[i], value));
                    }
                    return this.runtime.callFunction(node.name, resolvedArgs);
                case "ExpressionReference":
                    var refNode = node.children[0];
                    // Tag the node with a specific attribute so the type
                    // checker verify the type.
                    refNode.jmespathType = TOK_EXPREF;
                    return refNode;
                default:
                    throw new Error("Unknown node type: " + node.type);
            }
        },
        computeSliceParams: function(arrayLength, sliceParams) {
            var start = sliceParams[0];
            var stop = sliceParams[1];
            var step = sliceParams[2];
            var computed = [
                null,
                null,
                null
            ];
            if (step === null) {
                step = 1;
            } else if (step === 0) {
                var error = new Error("Invalid slice, step cannot be 0");
                error.name = "RuntimeError";
                throw error;
            }
            var stepValueNegative = step < 0 ? true : false;
            if (start === null) {
                start = stepValueNegative ? arrayLength - 1 : 0;
            } else {
                start = this.capSliceRange(arrayLength, start, step);
            }
            if (stop === null) {
                stop = stepValueNegative ? -1 : arrayLength;
            } else {
                stop = this.capSliceRange(arrayLength, stop, step);
            }
            computed[0] = start;
            computed[1] = stop;
            computed[2] = step;
            return computed;
        },
        capSliceRange: function(arrayLength, actualValue, step) {
            if (actualValue < 0) {
                actualValue += arrayLength;
                if (actualValue < 0) {
                    actualValue = step < 0 ? -1 : 0;
                }
            } else if (actualValue >= arrayLength) {
                actualValue = step < 0 ? arrayLength - 1 : arrayLength;
            }
            return actualValue;
        }
    };
    function Runtime(interpreter) {
        this._interpreter = interpreter;
        this.functionTable = {
            // name: [function, <signature>]
            // The <signature> can be:
            //
            // {
            //   args: [[type1, type2], [type1, type2]],
            //   variadic: true|false
            // }
            //
            // Each arg in the arg list is a list of valid types
            // (if the function is overloaded and supports multiple
            // types.  If the type is "any" then no type checking
            // occurs on the argument.  Variadic is optional
            // and if not provided is assumed to be false.
            abs: {
                _func: this._functionAbs,
                _signature: [
                    {
                        types: [
                            TYPE_NUMBER
                        ]
                    }
                ]
            },
            avg: {
                _func: this._functionAvg,
                _signature: [
                    {
                        types: [
                            TYPE_ARRAY_NUMBER
                        ]
                    }
                ]
            },
            ceil: {
                _func: this._functionCeil,
                _signature: [
                    {
                        types: [
                            TYPE_NUMBER
                        ]
                    }
                ]
            },
            contains: {
                _func: this._functionContains,
                _signature: [
                    {
                        types: [
                            TYPE_STRING,
                            TYPE_ARRAY
                        ]
                    },
                    {
                        types: [
                            TYPE_ANY
                        ]
                    }
                ]
            },
            "ends_with": {
                _func: this._functionEndsWith,
                _signature: [
                    {
                        types: [
                            TYPE_STRING
                        ]
                    },
                    {
                        types: [
                            TYPE_STRING
                        ]
                    }
                ]
            },
            floor: {
                _func: this._functionFloor,
                _signature: [
                    {
                        types: [
                            TYPE_NUMBER
                        ]
                    }
                ]
            },
            length: {
                _func: this._functionLength,
                _signature: [
                    {
                        types: [
                            TYPE_STRING,
                            TYPE_ARRAY,
                            TYPE_OBJECT
                        ]
                    }
                ]
            },
            map: {
                _func: this._functionMap,
                _signature: [
                    {
                        types: [
                            TYPE_EXPREF
                        ]
                    },
                    {
                        types: [
                            TYPE_ARRAY
                        ]
                    }
                ]
            },
            max: {
                _func: this._functionMax,
                _signature: [
                    {
                        types: [
                            TYPE_ARRAY_NUMBER,
                            TYPE_ARRAY_STRING
                        ]
                    }
                ]
            },
            "merge": {
                _func: this._functionMerge,
                _signature: [
                    {
                        types: [
                            TYPE_OBJECT
                        ],
                        variadic: true
                    }
                ]
            },
            "max_by": {
                _func: this._functionMaxBy,
                _signature: [
                    {
                        types: [
                            TYPE_ARRAY
                        ]
                    },
                    {
                        types: [
                            TYPE_EXPREF
                        ]
                    }
                ]
            },
            sum: {
                _func: this._functionSum,
                _signature: [
                    {
                        types: [
                            TYPE_ARRAY_NUMBER
                        ]
                    }
                ]
            },
            "starts_with": {
                _func: this._functionStartsWith,
                _signature: [
                    {
                        types: [
                            TYPE_STRING
                        ]
                    },
                    {
                        types: [
                            TYPE_STRING
                        ]
                    }
                ]
            },
            min: {
                _func: this._functionMin,
                _signature: [
                    {
                        types: [
                            TYPE_ARRAY_NUMBER,
                            TYPE_ARRAY_STRING
                        ]
                    }
                ]
            },
            "min_by": {
                _func: this._functionMinBy,
                _signature: [
                    {
                        types: [
                            TYPE_ARRAY
                        ]
                    },
                    {
                        types: [
                            TYPE_EXPREF
                        ]
                    }
                ]
            },
            type: {
                _func: this._functionType,
                _signature: [
                    {
                        types: [
                            TYPE_ANY
                        ]
                    }
                ]
            },
            keys: {
                _func: this._functionKeys,
                _signature: [
                    {
                        types: [
                            TYPE_OBJECT
                        ]
                    }
                ]
            },
            values: {
                _func: this._functionValues,
                _signature: [
                    {
                        types: [
                            TYPE_OBJECT
                        ]
                    }
                ]
            },
            sort: {
                _func: this._functionSort,
                _signature: [
                    {
                        types: [
                            TYPE_ARRAY_STRING,
                            TYPE_ARRAY_NUMBER
                        ]
                    }
                ]
            },
            "sort_by": {
                _func: this._functionSortBy,
                _signature: [
                    {
                        types: [
                            TYPE_ARRAY
                        ]
                    },
                    {
                        types: [
                            TYPE_EXPREF
                        ]
                    }
                ]
            },
            join: {
                _func: this._functionJoin,
                _signature: [
                    {
                        types: [
                            TYPE_STRING
                        ]
                    },
                    {
                        types: [
                            TYPE_ARRAY_STRING
                        ]
                    }
                ]
            },
            reverse: {
                _func: this._functionReverse,
                _signature: [
                    {
                        types: [
                            TYPE_STRING,
                            TYPE_ARRAY
                        ]
                    }
                ]
            },
            "to_array": {
                _func: this._functionToArray,
                _signature: [
                    {
                        types: [
                            TYPE_ANY
                        ]
                    }
                ]
            },
            "to_string": {
                _func: this._functionToString,
                _signature: [
                    {
                        types: [
                            TYPE_ANY
                        ]
                    }
                ]
            },
            "to_number": {
                _func: this._functionToNumber,
                _signature: [
                    {
                        types: [
                            TYPE_ANY
                        ]
                    }
                ]
            },
            "not_null": {
                _func: this._functionNotNull,
                _signature: [
                    {
                        types: [
                            TYPE_ANY
                        ],
                        variadic: true
                    }
                ]
            }
        };
    }
    Runtime.prototype = {
        callFunction: function(name, resolvedArgs) {
            var functionEntry = this.functionTable[name];
            if (functionEntry === undefined) {
                throw new Error("Unknown function: " + name + "()");
            }
            this._validateArgs(name, resolvedArgs, functionEntry._signature);
            return functionEntry._func.call(this, resolvedArgs);
        },
        _validateArgs: function(name, args, signature) {
            // Validating the args requires validating
            // the correct arity and the correct type of each arg.
            // If the last argument is declared as variadic, then we need
            // a minimum number of args to be required.  Otherwise it has to
            // be an exact amount.
            var pluralized;
            if (signature[signature.length - 1].variadic) {
                if (args.length < signature.length) {
                    pluralized = signature.length === 1 ? " argument" : " arguments";
                    throw new Error("ArgumentError: " + name + "() " + "takes at least" + signature.length + pluralized + " but received " + args.length);
                }
            } else if (args.length !== signature.length) {
                pluralized = signature.length === 1 ? " argument" : " arguments";
                throw new Error("ArgumentError: " + name + "() " + "takes " + signature.length + pluralized + " but received " + args.length);
            }
            var currentSpec;
            var actualType;
            var typeMatched;
            for(var i = 0; i < signature.length; i++){
                typeMatched = false;
                currentSpec = signature[i].types;
                actualType = this._getTypeName(args[i]);
                for(var j = 0; j < currentSpec.length; j++){
                    if (this._typeMatches(actualType, currentSpec[j], args[i])) {
                        typeMatched = true;
                        break;
                    }
                }
                if (!typeMatched) {
                    var expected = currentSpec.map(function(typeIdentifier) {
                        return TYPE_NAME_TABLE[typeIdentifier];
                    }).join(',');
                    throw new Error("TypeError: " + name + "() " + "expected argument " + (i + 1) + " to be type " + expected + " but received type " + TYPE_NAME_TABLE[actualType] + " instead.");
                }
            }
        },
        _typeMatches: function(actual, expected, argValue) {
            if (expected === TYPE_ANY) {
                return true;
            }
            if (expected === TYPE_ARRAY_STRING || expected === TYPE_ARRAY_NUMBER || expected === TYPE_ARRAY) {
                // The expected type can either just be array,
                // or it can require a specific subtype (array of numbers).
                //
                // The simplest case is if "array" with no subtype is specified.
                if (expected === TYPE_ARRAY) {
                    return actual === TYPE_ARRAY;
                } else if (actual === TYPE_ARRAY) {
                    // Otherwise we need to check subtypes.
                    // I think this has potential to be improved.
                    var subtype;
                    if (expected === TYPE_ARRAY_NUMBER) {
                        subtype = TYPE_NUMBER;
                    } else if (expected === TYPE_ARRAY_STRING) {
                        subtype = TYPE_STRING;
                    }
                    for(var i = 0; i < argValue.length; i++){
                        if (!this._typeMatches(this._getTypeName(argValue[i]), subtype, argValue[i])) {
                            return false;
                        }
                    }
                    return true;
                }
            } else {
                return actual === expected;
            }
        },
        _getTypeName: function(obj) {
            switch(Object.prototype.toString.call(obj)){
                case "[object String]":
                    return TYPE_STRING;
                case "[object Number]":
                    return TYPE_NUMBER;
                case "[object Array]":
                    return TYPE_ARRAY;
                case "[object Boolean]":
                    return TYPE_BOOLEAN;
                case "[object Null]":
                    return TYPE_NULL;
                case "[object Object]":
                    // Check if it's an expref.  If it has, it's been
                    // tagged with a jmespathType attr of 'Expref';
                    if (obj.jmespathType === TOK_EXPREF) {
                        return TYPE_EXPREF;
                    } else {
                        return TYPE_OBJECT;
                    }
            }
        },
        _functionStartsWith: function(resolvedArgs) {
            return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;
        },
        _functionEndsWith: function(resolvedArgs) {
            var searchStr = resolvedArgs[0];
            var suffix = resolvedArgs[1];
            return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;
        },
        _functionReverse: function(resolvedArgs) {
            var typeName = this._getTypeName(resolvedArgs[0]);
            if (typeName === TYPE_STRING) {
                var originalStr = resolvedArgs[0];
                var reversedStr = "";
                for(var i = originalStr.length - 1; i >= 0; i--){
                    reversedStr += originalStr[i];
                }
                return reversedStr;
            } else {
                var reversedArray = resolvedArgs[0].slice(0);
                reversedArray.reverse();
                return reversedArray;
            }
        },
        _functionAbs: function(resolvedArgs) {
            return Math.abs(resolvedArgs[0]);
        },
        _functionCeil: function(resolvedArgs) {
            return Math.ceil(resolvedArgs[0]);
        },
        _functionAvg: function(resolvedArgs) {
            var sum = 0;
            var inputArray = resolvedArgs[0];
            for(var i = 0; i < inputArray.length; i++){
                sum += inputArray[i];
            }
            return sum / inputArray.length;
        },
        _functionContains: function(resolvedArgs) {
            return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;
        },
        _functionFloor: function(resolvedArgs) {
            return Math.floor(resolvedArgs[0]);
        },
        _functionLength: function(resolvedArgs) {
            if (!isObject(resolvedArgs[0])) {
                return resolvedArgs[0].length;
            } else {
                // As far as I can tell, there's no way to get the length
                // of an object without O(n) iteration through the object.
                return Object.keys(resolvedArgs[0]).length;
            }
        },
        _functionMap: function(resolvedArgs) {
            var mapped = [];
            var interpreter = this._interpreter;
            var exprefNode = resolvedArgs[0];
            var elements = resolvedArgs[1];
            for(var i = 0; i < elements.length; i++){
                mapped.push(interpreter.visit(exprefNode, elements[i]));
            }
            return mapped;
        },
        _functionMerge: function(resolvedArgs) {
            var merged = {};
            for(var i = 0; i < resolvedArgs.length; i++){
                var current = resolvedArgs[i];
                for(var key in current){
                    merged[key] = current[key];
                }
            }
            return merged;
        },
        _functionMax: function(resolvedArgs) {
            if (resolvedArgs[0].length > 0) {
                var typeName = this._getTypeName(resolvedArgs[0][0]);
                if (typeName === TYPE_NUMBER) {
                    return Math.max.apply(Math, resolvedArgs[0]);
                } else {
                    var elements = resolvedArgs[0];
                    var maxElement = elements[0];
                    for(var i = 1; i < elements.length; i++){
                        if (maxElement.localeCompare(elements[i]) < 0) {
                            maxElement = elements[i];
                        }
                    }
                    return maxElement;
                }
            } else {
                return null;
            }
        },
        _functionMin: function(resolvedArgs) {
            if (resolvedArgs[0].length > 0) {
                var typeName = this._getTypeName(resolvedArgs[0][0]);
                if (typeName === TYPE_NUMBER) {
                    return Math.min.apply(Math, resolvedArgs[0]);
                } else {
                    var elements = resolvedArgs[0];
                    var minElement = elements[0];
                    for(var i = 1; i < elements.length; i++){
                        if (elements[i].localeCompare(minElement) < 0) {
                            minElement = elements[i];
                        }
                    }
                    return minElement;
                }
            } else {
                return null;
            }
        },
        _functionSum: function(resolvedArgs) {
            var sum = 0;
            var listToSum = resolvedArgs[0];
            for(var i = 0; i < listToSum.length; i++){
                sum += listToSum[i];
            }
            return sum;
        },
        _functionType: function(resolvedArgs) {
            switch(this._getTypeName(resolvedArgs[0])){
                case TYPE_NUMBER:
                    return "number";
                case TYPE_STRING:
                    return "string";
                case TYPE_ARRAY:
                    return "array";
                case TYPE_OBJECT:
                    return "object";
                case TYPE_BOOLEAN:
                    return "boolean";
                case TYPE_EXPREF:
                    return "expref";
                case TYPE_NULL:
                    return "null";
            }
        },
        _functionKeys: function(resolvedArgs) {
            return Object.keys(resolvedArgs[0]);
        },
        _functionValues: function(resolvedArgs) {
            var obj = resolvedArgs[0];
            var keys = Object.keys(obj);
            var values = [];
            for(var i = 0; i < keys.length; i++){
                values.push(obj[keys[i]]);
            }
            return values;
        },
        _functionJoin: function(resolvedArgs) {
            var joinChar = resolvedArgs[0];
            var listJoin = resolvedArgs[1];
            return listJoin.join(joinChar);
        },
        _functionToArray: function(resolvedArgs) {
            if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {
                return resolvedArgs[0];
            } else {
                return [
                    resolvedArgs[0]
                ];
            }
        },
        _functionToString: function(resolvedArgs) {
            if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {
                return resolvedArgs[0];
            } else {
                return JSON.stringify(resolvedArgs[0]);
            }
        },
        _functionToNumber: function(resolvedArgs) {
            var typeName = this._getTypeName(resolvedArgs[0]);
            var convertedValue;
            if (typeName === TYPE_NUMBER) {
                return resolvedArgs[0];
            } else if (typeName === TYPE_STRING) {
                convertedValue = +resolvedArgs[0];
                if (!isNaN(convertedValue)) {
                    return convertedValue;
                }
            }
            return null;
        },
        _functionNotNull: function(resolvedArgs) {
            for(var i = 0; i < resolvedArgs.length; i++){
                if (this._getTypeName(resolvedArgs[i]) !== TYPE_NULL) {
                    return resolvedArgs[i];
                }
            }
            return null;
        },
        _functionSort: function(resolvedArgs) {
            var sortedArray = resolvedArgs[0].slice(0);
            sortedArray.sort();
            return sortedArray;
        },
        _functionSortBy: function(resolvedArgs) {
            var sortedArray = resolvedArgs[0].slice(0);
            if (sortedArray.length === 0) {
                return sortedArray;
            }
            var interpreter = this._interpreter;
            var exprefNode = resolvedArgs[1];
            var requiredType = this._getTypeName(interpreter.visit(exprefNode, sortedArray[0]));
            if ([
                TYPE_NUMBER,
                TYPE_STRING
            ].indexOf(requiredType) < 0) {
                throw new Error("TypeError");
            }
            var that = this;
            // In order to get a stable sort out of an unstable
            // sort algorithm, we decorate/sort/undecorate (DSU)
            // by creating a new list of [index, element] pairs.
            // In the cmp function, if the evaluated elements are
            // equal, then the index will be used as the tiebreaker.
            // After the decorated list has been sorted, it will be
            // undecorated to extract the original elements.
            var decorated = [];
            for(var i = 0; i < sortedArray.length; i++){
                decorated.push([
                    i,
                    sortedArray[i]
                ]);
            }
            decorated.sort(function(a, b) {
                var exprA = interpreter.visit(exprefNode, a[1]);
                var exprB = interpreter.visit(exprefNode, b[1]);
                if (that._getTypeName(exprA) !== requiredType) {
                    throw new Error("TypeError: expected " + requiredType + ", received " + that._getTypeName(exprA));
                } else if (that._getTypeName(exprB) !== requiredType) {
                    throw new Error("TypeError: expected " + requiredType + ", received " + that._getTypeName(exprB));
                }
                if (exprA > exprB) {
                    return 1;
                } else if (exprA < exprB) {
                    return -1;
                } else {
                    // If they're equal compare the items by their
                    // order to maintain relative order of equal keys
                    // (i.e. to get a stable sort).
                    return a[0] - b[0];
                }
            });
            // Undecorate: extract out the original list elements.
            for(var j = 0; j < decorated.length; j++){
                sortedArray[j] = decorated[j][1];
            }
            return sortedArray;
        },
        _functionMaxBy: function(resolvedArgs) {
            var exprefNode = resolvedArgs[1];
            var resolvedArray = resolvedArgs[0];
            var keyFunction = this.createKeyFunction(exprefNode, [
                TYPE_NUMBER,
                TYPE_STRING
            ]);
            var maxNumber = -Infinity;
            var maxRecord;
            var current;
            for(var i = 0; i < resolvedArray.length; i++){
                current = keyFunction(resolvedArray[i]);
                if (current > maxNumber) {
                    maxNumber = current;
                    maxRecord = resolvedArray[i];
                }
            }
            return maxRecord;
        },
        _functionMinBy: function(resolvedArgs) {
            var exprefNode = resolvedArgs[1];
            var resolvedArray = resolvedArgs[0];
            var keyFunction = this.createKeyFunction(exprefNode, [
                TYPE_NUMBER,
                TYPE_STRING
            ]);
            var minNumber = Infinity;
            var minRecord;
            var current;
            for(var i = 0; i < resolvedArray.length; i++){
                current = keyFunction(resolvedArray[i]);
                if (current < minNumber) {
                    minNumber = current;
                    minRecord = resolvedArray[i];
                }
            }
            return minRecord;
        },
        createKeyFunction: function(exprefNode, allowedTypes) {
            var that = this;
            var interpreter = this._interpreter;
            var keyFunc = function(x) {
                var current = interpreter.visit(exprefNode, x);
                if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {
                    var msg = "TypeError: expected one of " + allowedTypes + ", received " + that._getTypeName(current);
                    throw new Error(msg);
                }
                return current;
            };
            return keyFunc;
        }
    };
    function compile(stream) {
        var parser = new Parser();
        var ast = parser.parse(stream);
        return ast;
    }
    function tokenize(stream) {
        var lexer = new Lexer();
        return lexer.tokenize(stream);
    }
    function search(data, expression) {
        var parser = new Parser();
        // This needs to be improved.  Both the interpreter and runtime depend on
        // each other.  The runtime needs the interpreter to support exprefs.
        // There's likely a clean way to avoid the cyclic dependency.
        var runtime = new Runtime();
        var interpreter = new TreeInterpreter(runtime);
        runtime._interpreter = interpreter;
        var node = parser.parse(expression);
        return interpreter.search(node, data);
    }
    exports1.tokenize = tokenize;
    exports1.compile = compile;
    exports1.search = search;
    exports1.strictDeepEqual = strictDeepEqual;
})(("TURBOPACK compile-time falsy", 0) ? ("TURBOPACK unreachable", undefined) : exports);
}}),
"[project]/node_modules/aws-sdk/node_modules/uuid/dist/rng.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = rng;
var _crypto = _interopRequireDefault(__turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function rng() {
    return _crypto.default.randomBytes(16);
}
}}),
"[project]/node_modules/aws-sdk/node_modules/uuid/dist/bytesToUuid.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */ var byteToHex = [];
for(var i = 0; i < 256; ++i){
    byteToHex[i] = (i + 0x100).toString(16).substr(1);
}
function bytesToUuid(buf, offset) {
    var i = offset || 0;
    var bth = byteToHex; // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
    return [
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        '-',
        bth[buf[i++]],
        bth[buf[i++]],
        '-',
        bth[buf[i++]],
        bth[buf[i++]],
        '-',
        bth[buf[i++]],
        bth[buf[i++]],
        '-',
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]]
    ].join('');
}
var _default = bytesToUuid;
exports.default = _default;
}}),
"[project]/node_modules/aws-sdk/node_modules/uuid/dist/v1.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _rng = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/aws-sdk/node_modules/uuid/dist/rng.js [app-rsc] (ecmascript)"));
var _bytesToUuid = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/aws-sdk/node_modules/uuid/dist/bytesToUuid.js [app-rsc] (ecmascript)"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
var _nodeId;
var _clockseq; // Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details
function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];
    options = options || {};
    var node = options.node || _nodeId;
    var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
    // specified.  We do this lazily to minimize issues related to insufficient
    // system entropy.  See #189
    if (node == null || clockseq == null) {
        var seedBytes = options.random || (options.rng || _rng.default)();
        if (node == null) {
            // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
            node = _nodeId = [
                seedBytes[0] | 0x01,
                seedBytes[1],
                seedBytes[2],
                seedBytes[3],
                seedBytes[4],
                seedBytes[5]
            ];
        }
        if (clockseq == null) {
            // Per 4.2.2, randomize (14 bit) clockseq
            clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
        }
    } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime(); // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)
    var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq === undefined) {
        clockseq = clockseq + 1 & 0x3fff;
    } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
        nsecs = 0;
    } // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000; // `time_low`
    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff; // `time_mid`
    var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff; // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`
    b[i++] = clockseq & 0xff; // `node`
    for(var n = 0; n < 6; ++n){
        b[i + n] = node[n];
    }
    return buf ? buf : (0, _bytesToUuid.default)(b);
}
var _default = v1;
exports.default = _default;
}}),
"[project]/node_modules/aws-sdk/node_modules/uuid/dist/v35.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = _default;
exports.URL = exports.DNS = void 0;
var _bytesToUuid = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/aws-sdk/node_modules/uuid/dist/bytesToUuid.js [app-rsc] (ecmascript)"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function uuidToBytes(uuid) {
    // Note: We assume we're being passed a valid uuid string
    var bytes = [];
    uuid.replace(/[a-fA-F0-9]{2}/g, function(hex) {
        bytes.push(parseInt(hex, 16));
    });
    return bytes;
}
function stringToBytes(str) {
    str = unescape(encodeURIComponent(str)); // UTF8 escape
    var bytes = new Array(str.length);
    for(var i = 0; i < str.length; i++){
        bytes[i] = str.charCodeAt(i);
    }
    return bytes;
}
const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;
function _default(name, version, hashfunc) {
    var generateUUID = function(value, namespace, buf, offset) {
        var off = buf && offset || 0;
        if (typeof value == 'string') value = stringToBytes(value);
        if (typeof namespace == 'string') namespace = uuidToBytes(namespace);
        if (!Array.isArray(value)) throw TypeError('value must be an array of bytes');
        if (!Array.isArray(namespace) || namespace.length !== 16) throw TypeError('namespace must be uuid string or an Array of 16 byte values'); // Per 4.3
        var bytes = hashfunc(namespace.concat(value));
        bytes[6] = bytes[6] & 0x0f | version;
        bytes[8] = bytes[8] & 0x3f | 0x80;
        if (buf) {
            for(var idx = 0; idx < 16; ++idx){
                buf[off + idx] = bytes[idx];
            }
        }
        return buf || (0, _bytesToUuid.default)(bytes);
    }; // Function#name is not settable on some platforms (#270)
    try {
        generateUUID.name = name;
    } catch (err) {} // For CommonJS default export support
    generateUUID.DNS = DNS;
    generateUUID.URL = URL;
    return generateUUID;
}
}}),
"[project]/node_modules/aws-sdk/node_modules/uuid/dist/md5.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _crypto = _interopRequireDefault(__turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function md5(bytes) {
    if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
    } else if (typeof bytes === 'string') {
        bytes = Buffer.from(bytes, 'utf8');
    }
    return _crypto.default.createHash('md5').update(bytes).digest();
}
var _default = md5;
exports.default = _default;
}}),
"[project]/node_modules/aws-sdk/node_modules/uuid/dist/v3.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _v = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/aws-sdk/node_modules/uuid/dist/v35.js [app-rsc] (ecmascript)"));
var _md = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/aws-sdk/node_modules/uuid/dist/md5.js [app-rsc] (ecmascript)"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports.default = _default;
}}),
"[project]/node_modules/aws-sdk/node_modules/uuid/dist/v4.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _rng = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/aws-sdk/node_modules/uuid/dist/rng.js [app-rsc] (ecmascript)"));
var _bytesToUuid = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/aws-sdk/node_modules/uuid/dist/bytesToUuid.js [app-rsc] (ecmascript)"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function v4(options, buf, offset) {
    var i = buf && offset || 0;
    if (typeof options == 'string') {
        buf = options === 'binary' ? new Array(16) : null;
        options = null;
    }
    options = options || {};
    var rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided
    if (buf) {
        for(var ii = 0; ii < 16; ++ii){
            buf[i + ii] = rnds[ii];
        }
    }
    return buf || (0, _bytesToUuid.default)(rnds);
}
var _default = v4;
exports.default = _default;
}}),
"[project]/node_modules/aws-sdk/node_modules/uuid/dist/sha1.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _crypto = _interopRequireDefault(__turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function sha1(bytes) {
    if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
    } else if (typeof bytes === 'string') {
        bytes = Buffer.from(bytes, 'utf8');
    }
    return _crypto.default.createHash('sha1').update(bytes).digest();
}
var _default = sha1;
exports.default = _default;
}}),
"[project]/node_modules/aws-sdk/node_modules/uuid/dist/v5.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _v = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/aws-sdk/node_modules/uuid/dist/v35.js [app-rsc] (ecmascript)"));
var _sha = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/aws-sdk/node_modules/uuid/dist/sha1.js [app-rsc] (ecmascript)"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports.default = _default;
}}),
"[project]/node_modules/aws-sdk/node_modules/uuid/dist/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "v1", {
    enumerable: true,
    get: function() {
        return _v.default;
    }
});
Object.defineProperty(exports, "v3", {
    enumerable: true,
    get: function() {
        return _v2.default;
    }
});
Object.defineProperty(exports, "v4", {
    enumerable: true,
    get: function() {
        return _v3.default;
    }
});
Object.defineProperty(exports, "v5", {
    enumerable: true,
    get: function() {
        return _v4.default;
    }
});
var _v = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/aws-sdk/node_modules/uuid/dist/v1.js [app-rsc] (ecmascript)"));
var _v2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/aws-sdk/node_modules/uuid/dist/v3.js [app-rsc] (ecmascript)"));
var _v3 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/aws-sdk/node_modules/uuid/dist/v4.js [app-rsc] (ecmascript)"));
var _v4 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/aws-sdk/node_modules/uuid/dist/v5.js [app-rsc] (ecmascript)"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
}}),
"[project]/node_modules/xml2js/lib/defaults.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// Generated by CoffeeScript 1.12.7
(function() {
    exports.defaults = {
        "0.1": {
            explicitCharkey: false,
            trim: true,
            normalize: true,
            normalizeTags: false,
            attrkey: "@",
            charkey: "#",
            explicitArray: false,
            ignoreAttrs: false,
            mergeAttrs: false,
            explicitRoot: false,
            validator: null,
            xmlns: false,
            explicitChildren: false,
            childkey: '@@',
            charsAsChildren: false,
            includeWhiteChars: false,
            async: false,
            strict: true,
            attrNameProcessors: null,
            attrValueProcessors: null,
            tagNameProcessors: null,
            valueProcessors: null,
            emptyTag: ''
        },
        "0.2": {
            explicitCharkey: false,
            trim: false,
            normalize: false,
            normalizeTags: false,
            attrkey: "$",
            charkey: "_",
            explicitArray: true,
            ignoreAttrs: false,
            mergeAttrs: false,
            explicitRoot: true,
            validator: null,
            xmlns: false,
            explicitChildren: false,
            preserveChildrenOrder: false,
            childkey: '$$',
            charsAsChildren: false,
            includeWhiteChars: false,
            async: false,
            strict: true,
            attrNameProcessors: null,
            attrValueProcessors: null,
            tagNameProcessors: null,
            valueProcessors: null,
            rootName: 'root',
            xmldec: {
                'version': '1.0',
                'encoding': 'UTF-8',
                'standalone': true
            },
            doctype: null,
            renderOpts: {
                'pretty': true,
                'indent': '  ',
                'newline': '\n'
            },
            headless: false,
            chunkSize: 10000,
            emptyTag: '',
            cdata: false
        }
    };
}).call(this);
}}),
"[project]/node_modules/xml2js/lib/builder.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// Generated by CoffeeScript 1.12.7
(function() {
    "use strict";
    var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA, hasProp = {}.hasOwnProperty;
    builder = __turbopack_context__.r("[project]/node_modules/xmlbuilder/lib/index.js [app-rsc] (ecmascript)");
    defaults = __turbopack_context__.r("[project]/node_modules/xml2js/lib/defaults.js [app-rsc] (ecmascript)").defaults;
    requiresCDATA = function(entry) {
        return typeof entry === "string" && (entry.indexOf('&') >= 0 || entry.indexOf('>') >= 0 || entry.indexOf('<') >= 0);
    };
    wrapCDATA = function(entry) {
        return "<![CDATA[" + escapeCDATA(entry) + "]]>";
    };
    escapeCDATA = function(entry) {
        return entry.replace(']]>', ']]]]><![CDATA[>');
    };
    exports.Builder = function() {
        function Builder(opts) {
            var key, ref, value;
            this.options = {};
            ref = defaults["0.2"];
            for(key in ref){
                if (!hasProp.call(ref, key)) continue;
                value = ref[key];
                this.options[key] = value;
            }
            for(key in opts){
                if (!hasProp.call(opts, key)) continue;
                value = opts[key];
                this.options[key] = value;
            }
        }
        Builder.prototype.buildObject = function(rootObj) {
            var attrkey, charkey, render, rootElement, rootName;
            attrkey = this.options.attrkey;
            charkey = this.options.charkey;
            if (Object.keys(rootObj).length === 1 && this.options.rootName === defaults['0.2'].rootName) {
                rootName = Object.keys(rootObj)[0];
                rootObj = rootObj[rootName];
            } else {
                rootName = this.options.rootName;
            }
            render = function(_this) {
                return function(element, obj) {
                    var attr, child, entry, index, key, value;
                    if (typeof obj !== 'object') {
                        if (_this.options.cdata && requiresCDATA(obj)) {
                            element.raw(wrapCDATA(obj));
                        } else {
                            element.txt(obj);
                        }
                    } else if (Array.isArray(obj)) {
                        for(index in obj){
                            if (!hasProp.call(obj, index)) continue;
                            child = obj[index];
                            for(key in child){
                                entry = child[key];
                                element = render(element.ele(key), entry).up();
                            }
                        }
                    } else {
                        for(key in obj){
                            if (!hasProp.call(obj, key)) continue;
                            child = obj[key];
                            if (key === attrkey) {
                                if (typeof child === "object") {
                                    for(attr in child){
                                        value = child[attr];
                                        element = element.att(attr, value);
                                    }
                                }
                            } else if (key === charkey) {
                                if (_this.options.cdata && requiresCDATA(child)) {
                                    element = element.raw(wrapCDATA(child));
                                } else {
                                    element = element.txt(child);
                                }
                            } else if (Array.isArray(child)) {
                                for(index in child){
                                    if (!hasProp.call(child, index)) continue;
                                    entry = child[index];
                                    if (typeof entry === 'string') {
                                        if (_this.options.cdata && requiresCDATA(entry)) {
                                            element = element.ele(key).raw(wrapCDATA(entry)).up();
                                        } else {
                                            element = element.ele(key, entry).up();
                                        }
                                    } else {
                                        element = render(element.ele(key), entry).up();
                                    }
                                }
                            } else if (typeof child === "object") {
                                element = render(element.ele(key), child).up();
                            } else {
                                if (typeof child === 'string' && _this.options.cdata && requiresCDATA(child)) {
                                    element = element.ele(key).raw(wrapCDATA(child)).up();
                                } else {
                                    if (child == null) {
                                        child = '';
                                    }
                                    element = element.ele(key, child.toString()).up();
                                }
                            }
                        }
                    }
                    return element;
                };
            }(this);
            rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
                headless: this.options.headless,
                allowSurrogateChars: this.options.allowSurrogateChars
            });
            return render(rootElement, rootObj).end(this.options.renderOpts);
        };
        return Builder;
    }();
}).call(this);
}}),
"[project]/node_modules/xml2js/lib/bom.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// Generated by CoffeeScript 1.12.7
(function() {
    "use strict";
    exports.stripBOM = function(str) {
        if (str[0] === '\uFEFF') {
            return str.substring(1);
        } else {
            return str;
        }
    };
}).call(this);
}}),
"[project]/node_modules/xml2js/lib/processors.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// Generated by CoffeeScript 1.12.7
(function() {
    "use strict";
    var prefixMatch;
    prefixMatch = new RegExp(/(?!xmlns)^.*:/);
    exports.normalize = function(str) {
        return str.toLowerCase();
    };
    exports.firstCharLowerCase = function(str) {
        return str.charAt(0).toLowerCase() + str.slice(1);
    };
    exports.stripPrefix = function(str) {
        return str.replace(prefixMatch, '');
    };
    exports.parseNumbers = function(str) {
        if (!isNaN(str)) {
            str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
        }
        return str;
    };
    exports.parseBooleans = function(str) {
        if (/^(?:true|false)$/i.test(str)) {
            str = str.toLowerCase() === 'true';
        }
        return str;
    };
}).call(this);
}}),
"[project]/node_modules/xml2js/lib/parser.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// Generated by CoffeeScript 1.12.7
(function() {
    "use strict";
    var bom, defaults, defineProperty, events, isEmpty, processItem, processors, sax, setImmediate, bind = function(fn, me) {
        return function() {
            return fn.apply(me, arguments);
        };
    }, extend = function(child, parent) {
        for(var key in parent){
            if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
    sax = __turbopack_context__.r("[project]/node_modules/sax/lib/sax.js [app-rsc] (ecmascript)");
    events = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
    bom = __turbopack_context__.r("[project]/node_modules/xml2js/lib/bom.js [app-rsc] (ecmascript)");
    processors = __turbopack_context__.r("[project]/node_modules/xml2js/lib/processors.js [app-rsc] (ecmascript)");
    setImmediate = __turbopack_context__.r("[externals]/timers [external] (timers, cjs)").setImmediate;
    defaults = __turbopack_context__.r("[project]/node_modules/xml2js/lib/defaults.js [app-rsc] (ecmascript)").defaults;
    isEmpty = function(thing) {
        return typeof thing === "object" && thing != null && Object.keys(thing).length === 0;
    };
    processItem = function(processors, item, key) {
        var i, len, process;
        for(i = 0, len = processors.length; i < len; i++){
            process = processors[i];
            item = process(item, key);
        }
        return item;
    };
    defineProperty = function(obj, key, value) {
        var descriptor;
        descriptor = Object.create(null);
        descriptor.value = value;
        descriptor.writable = true;
        descriptor.enumerable = true;
        descriptor.configurable = true;
        return Object.defineProperty(obj, key, descriptor);
    };
    exports.Parser = function(superClass) {
        extend(Parser, superClass);
        function Parser(opts) {
            this.parseStringPromise = bind(this.parseStringPromise, this);
            this.parseString = bind(this.parseString, this);
            this.reset = bind(this.reset, this);
            this.assignOrPush = bind(this.assignOrPush, this);
            this.processAsync = bind(this.processAsync, this);
            var key, ref, value;
            if (!(this instanceof exports.Parser)) {
                return new exports.Parser(opts);
            }
            this.options = {};
            ref = defaults["0.2"];
            for(key in ref){
                if (!hasProp.call(ref, key)) continue;
                value = ref[key];
                this.options[key] = value;
            }
            for(key in opts){
                if (!hasProp.call(opts, key)) continue;
                value = opts[key];
                this.options[key] = value;
            }
            if (this.options.xmlns) {
                this.options.xmlnskey = this.options.attrkey + "ns";
            }
            if (this.options.normalizeTags) {
                if (!this.options.tagNameProcessors) {
                    this.options.tagNameProcessors = [];
                }
                this.options.tagNameProcessors.unshift(processors.normalize);
            }
            this.reset();
        }
        Parser.prototype.processAsync = function() {
            var chunk, err;
            try {
                if (this.remaining.length <= this.options.chunkSize) {
                    chunk = this.remaining;
                    this.remaining = '';
                    this.saxParser = this.saxParser.write(chunk);
                    return this.saxParser.close();
                } else {
                    chunk = this.remaining.substr(0, this.options.chunkSize);
                    this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
                    this.saxParser = this.saxParser.write(chunk);
                    return setImmediate(this.processAsync);
                }
            } catch (error1) {
                err = error1;
                if (!this.saxParser.errThrown) {
                    this.saxParser.errThrown = true;
                    return this.emit(err);
                }
            }
        };
        Parser.prototype.assignOrPush = function(obj, key, newValue) {
            if (!(key in obj)) {
                if (!this.options.explicitArray) {
                    return defineProperty(obj, key, newValue);
                } else {
                    return defineProperty(obj, key, [
                        newValue
                    ]);
                }
            } else {
                if (!(obj[key] instanceof Array)) {
                    defineProperty(obj, key, [
                        obj[key]
                    ]);
                }
                return obj[key].push(newValue);
            }
        };
        Parser.prototype.reset = function() {
            var attrkey, charkey, ontext, stack;
            this.removeAllListeners();
            this.saxParser = sax.parser(this.options.strict, {
                trim: false,
                normalize: false,
                xmlns: this.options.xmlns
            });
            this.saxParser.errThrown = false;
            this.saxParser.onerror = function(_this) {
                return function(error) {
                    _this.saxParser.resume();
                    if (!_this.saxParser.errThrown) {
                        _this.saxParser.errThrown = true;
                        return _this.emit("error", error);
                    }
                };
            }(this);
            this.saxParser.onend = function(_this) {
                return function() {
                    if (!_this.saxParser.ended) {
                        _this.saxParser.ended = true;
                        return _this.emit("end", _this.resultObject);
                    }
                };
            }(this);
            this.saxParser.ended = false;
            this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
            this.resultObject = null;
            stack = [];
            attrkey = this.options.attrkey;
            charkey = this.options.charkey;
            this.saxParser.onopentag = function(_this) {
                return function(node) {
                    var key, newValue, obj, processedKey, ref;
                    obj = {};
                    obj[charkey] = "";
                    if (!_this.options.ignoreAttrs) {
                        ref = node.attributes;
                        for(key in ref){
                            if (!hasProp.call(ref, key)) continue;
                            if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                                obj[attrkey] = {};
                            }
                            newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
                            processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
                            if (_this.options.mergeAttrs) {
                                _this.assignOrPush(obj, processedKey, newValue);
                            } else {
                                defineProperty(obj[attrkey], processedKey, newValue);
                            }
                        }
                    }
                    obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
                    if (_this.options.xmlns) {
                        obj[_this.options.xmlnskey] = {
                            uri: node.uri,
                            local: node.local
                        };
                    }
                    return stack.push(obj);
                };
            }(this);
            this.saxParser.onclosetag = function(_this) {
                return function() {
                    var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
                    obj = stack.pop();
                    nodeName = obj["#name"];
                    if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
                        delete obj["#name"];
                    }
                    if (obj.cdata === true) {
                        cdata = obj.cdata;
                        delete obj.cdata;
                    }
                    s = stack[stack.length - 1];
                    if (obj[charkey].match(/^\s*$/) && !cdata) {
                        emptyStr = obj[charkey];
                        delete obj[charkey];
                    } else {
                        if (_this.options.trim) {
                            obj[charkey] = obj[charkey].trim();
                        }
                        if (_this.options.normalize) {
                            obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
                        }
                        obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
                        if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                            obj = obj[charkey];
                        }
                    }
                    if (isEmpty(obj)) {
                        if (typeof _this.options.emptyTag === 'function') {
                            obj = _this.options.emptyTag();
                        } else {
                            obj = _this.options.emptyTag !== '' ? _this.options.emptyTag : emptyStr;
                        }
                    }
                    if (_this.options.validator != null) {
                        xpath = "/" + (function() {
                            var i, len, results;
                            results = [];
                            for(i = 0, len = stack.length; i < len; i++){
                                node = stack[i];
                                results.push(node["#name"]);
                            }
                            return results;
                        })().concat(nodeName).join("/");
                        (function() {
                            var err;
                            try {
                                return obj = _this.options.validator(xpath, s && s[nodeName], obj);
                            } catch (error1) {
                                err = error1;
                                return _this.emit("error", err);
                            }
                        })();
                    }
                    if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === 'object') {
                        if (!_this.options.preserveChildrenOrder) {
                            node = {};
                            if (_this.options.attrkey in obj) {
                                node[_this.options.attrkey] = obj[_this.options.attrkey];
                                delete obj[_this.options.attrkey];
                            }
                            if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                                node[_this.options.charkey] = obj[_this.options.charkey];
                                delete obj[_this.options.charkey];
                            }
                            if (Object.getOwnPropertyNames(obj).length > 0) {
                                node[_this.options.childkey] = obj;
                            }
                            obj = node;
                        } else if (s) {
                            s[_this.options.childkey] = s[_this.options.childkey] || [];
                            objClone = {};
                            for(key in obj){
                                if (!hasProp.call(obj, key)) continue;
                                defineProperty(objClone, key, obj[key]);
                            }
                            s[_this.options.childkey].push(objClone);
                            delete obj["#name"];
                            if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                                obj = obj[charkey];
                            }
                        }
                    }
                    if (stack.length > 0) {
                        return _this.assignOrPush(s, nodeName, obj);
                    } else {
                        if (_this.options.explicitRoot) {
                            old = obj;
                            obj = {};
                            defineProperty(obj, nodeName, old);
                        }
                        _this.resultObject = obj;
                        _this.saxParser.ended = true;
                        return _this.emit("end", _this.resultObject);
                    }
                };
            }(this);
            ontext = function(_this) {
                return function(text) {
                    var charChild, s;
                    s = stack[stack.length - 1];
                    if (s) {
                        s[charkey] += text;
                        if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\n/g, '').trim() !== '')) {
                            s[_this.options.childkey] = s[_this.options.childkey] || [];
                            charChild = {
                                '#name': '__text__'
                            };
                            charChild[charkey] = text;
                            if (_this.options.normalize) {
                                charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
                            }
                            s[_this.options.childkey].push(charChild);
                        }
                        return s;
                    }
                };
            }(this);
            this.saxParser.ontext = ontext;
            return this.saxParser.oncdata = function(_this) {
                return function(text) {
                    var s;
                    s = ontext(text);
                    if (s) {
                        return s.cdata = true;
                    }
                };
            }(this);
        };
        Parser.prototype.parseString = function(str, cb) {
            var err;
            if (cb != null && typeof cb === "function") {
                this.on("end", function(result) {
                    this.reset();
                    return cb(null, result);
                });
                this.on("error", function(err) {
                    this.reset();
                    return cb(err);
                });
            }
            try {
                str = str.toString();
                if (str.trim() === '') {
                    this.emit("end", null);
                    return true;
                }
                str = bom.stripBOM(str);
                if (this.options.async) {
                    this.remaining = str;
                    setImmediate(this.processAsync);
                    return this.saxParser;
                }
                return this.saxParser.write(str).close();
            } catch (error1) {
                err = error1;
                if (!(this.saxParser.errThrown || this.saxParser.ended)) {
                    this.emit('error', err);
                    return this.saxParser.errThrown = true;
                } else if (this.saxParser.ended) {
                    throw err;
                }
            }
        };
        Parser.prototype.parseStringPromise = function(str) {
            return new Promise(function(_this) {
                return function(resolve, reject) {
                    return _this.parseString(str, function(err, value) {
                        if (err) {
                            return reject(err);
                        } else {
                            return resolve(value);
                        }
                    });
                };
            }(this));
        };
        return Parser;
    }(events);
    exports.parseString = function(str, a, b) {
        var cb, options, parser;
        if (b != null) {
            if (typeof b === 'function') {
                cb = b;
            }
            if (typeof a === 'object') {
                options = a;
            }
        } else {
            if (typeof a === 'function') {
                cb = a;
            }
            options = {};
        }
        parser = new exports.Parser(options);
        return parser.parseString(str, cb);
    };
    exports.parseStringPromise = function(str, a) {
        var options, parser;
        if (typeof a === 'object') {
            options = a;
        }
        parser = new exports.Parser(options);
        return parser.parseStringPromise(str);
    };
}).call(this);
}}),
"[project]/node_modules/xml2js/lib/xml2js.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// Generated by CoffeeScript 1.12.7
(function() {
    "use strict";
    var builder, defaults, parser, processors, extend = function(child, parent) {
        for(var key in parent){
            if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
    defaults = __turbopack_context__.r("[project]/node_modules/xml2js/lib/defaults.js [app-rsc] (ecmascript)");
    builder = __turbopack_context__.r("[project]/node_modules/xml2js/lib/builder.js [app-rsc] (ecmascript)");
    parser = __turbopack_context__.r("[project]/node_modules/xml2js/lib/parser.js [app-rsc] (ecmascript)");
    processors = __turbopack_context__.r("[project]/node_modules/xml2js/lib/processors.js [app-rsc] (ecmascript)");
    exports.defaults = defaults.defaults;
    exports.processors = processors;
    exports.ValidationError = function(superClass) {
        extend(ValidationError, superClass);
        function ValidationError(message) {
            this.message = message;
        }
        return ValidationError;
    }(Error);
    exports.Builder = builder.Builder;
    exports.Parser = parser.Parser;
    exports.parseString = parser.parseString;
    exports.parseStringPromise = parser.parseStringPromise;
}).call(this);
}}),
"[project]/node_modules/sax/lib/sax.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
;
(function(sax) {
    sax.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
    };
    sax.SAXParser = SAXParser;
    sax.SAXStream = SAXStream;
    sax.createStream = createStream;
    // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
    // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
    // since that's the earliest that a buffer overrun could occur.  This way, checks are
    // as rare as required, but as often as necessary to ensure never crossing this bound.
    // Furthermore, buffers are only tested at most once per write(), so passing a very
    // large string into write() might have undesirable effects, but this is manageable by
    // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
    // edge case, result in creating at most one complete copy of the string passed in.
    // Set to Infinity to have unlimited buffers.
    sax.MAX_BUFFER_LENGTH = 64 * 1024;
    var buffers = [
        'comment',
        'sgmlDecl',
        'textNode',
        'tagName',
        'doctype',
        'procInstName',
        'procInstBody',
        'entity',
        'attribName',
        'attribValue',
        'cdata',
        'script'
    ];
    sax.EVENTS = [
        'text',
        'processinginstruction',
        'sgmldeclaration',
        'doctype',
        'comment',
        'opentagstart',
        'attribute',
        'opentag',
        'closetag',
        'opencdata',
        'cdata',
        'closecdata',
        'error',
        'end',
        'ready',
        'script',
        'opennamespace',
        'closenamespace'
    ];
    function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
            return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = '';
        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase';
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
        parser.attribList = [];
        // namespaces form a prototype chain.
        // it always points at the current tag,
        // which protos to its parent tag.
        if (parser.opt.xmlns) {
            parser.ns = Object.create(rootNS);
        }
        // mostly just for error reporting
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
            parser.position = parser.line = parser.column = 0;
        }
        emit(parser, 'onready');
    }
    if (!Object.create) {
        Object.create = function(o) {
            function F() {}
            F.prototype = o;
            var newf = new F();
            return newf;
        };
    }
    if (!Object.keys) {
        Object.keys = function(o) {
            var a = [];
            for(var i in o)if (o.hasOwnProperty(i)) a.push(i);
            return a;
        };
    }
    function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for(var i = 0, l = buffers.length; i < l; i++){
            var len = parser[buffers[i]].length;
            if (len > maxAllowed) {
                // Text/cdata nodes can get big, and since they're buffered,
                // we can get here under normal conditions.
                // Avoid issues by emitting the text node now,
                // so at least it won't get any bigger.
                switch(buffers[i]){
                    case 'textNode':
                        closeText(parser);
                        break;
                    case 'cdata':
                        emitNode(parser, 'oncdata', parser.cdata);
                        parser.cdata = '';
                        break;
                    case 'script':
                        emitNode(parser, 'onscript', parser.script);
                        parser.script = '';
                        break;
                    default:
                        error(parser, 'Max buffer length exceeded: ' + buffers[i]);
                }
            }
            maxActual = Math.max(maxActual, len);
        }
        // schedule the next check for the earliest possible buffer overrun.
        var m = sax.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
    }
    function clearBuffers(parser) {
        for(var i = 0, l = buffers.length; i < l; i++){
            parser[buffers[i]] = '';
        }
    }
    function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== '') {
            emitNode(parser, 'oncdata', parser.cdata);
            parser.cdata = '';
        }
        if (parser.script !== '') {
            emitNode(parser, 'onscript', parser.script);
            parser.script = '';
        }
    }
    SAXParser.prototype = {
        end: function() {
            end(this);
        },
        write: write,
        resume: function() {
            this.error = null;
            return this;
        },
        close: function() {
            return this.write(null);
        },
        flush: function() {
            flushBuffers(this);
        }
    };
    var Stream;
    try {
        Stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Stream;
    } catch (ex) {
        Stream = function() {};
    }
    var streamWraps = sax.EVENTS.filter(function(ev) {
        return ev !== 'error' && ev !== 'end';
    });
    function createStream(strict, opt) {
        return new SAXStream(strict, opt);
    }
    function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
            return new SAXStream(strict, opt);
        }
        Stream.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
            me.emit('end');
        };
        this._parser.onerror = function(er) {
            me.emit('error', er);
            // if didn't throw, then means error was handled.
            // go ahead and clear error, so we can write again.
            me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
            Object.defineProperty(me, 'on' + ev, {
                get: function() {
                    return me._parser['on' + ev];
                },
                set: function(h) {
                    if (!h) {
                        me.removeAllListeners(ev);
                        me._parser['on' + ev] = h;
                        return h;
                    }
                    me.on(ev, h);
                },
                enumerable: true,
                configurable: false
            });
        });
    }
    SAXStream.prototype = Object.create(Stream.prototype, {
        constructor: {
            value: SAXStream
        }
    });
    SAXStream.prototype.write = function(data) {
        if (typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function' && Buffer.isBuffer(data)) {
            if (!this._decoder) {
                var SD = __turbopack_context__.r("[externals]/string_decoder [external] (string_decoder, cjs)").StringDecoder;
                this._decoder = new SD('utf8');
            }
            data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit('data', data);
        return true;
    };
    SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) {
            this.write(chunk);
        }
        this._parser.end();
        return true;
    };
    SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
            me._parser['on' + ev] = function() {
                var args = arguments.length === 1 ? [
                    arguments[0]
                ] : Array.apply(null, arguments);
                args.splice(0, 0, ev);
                me.emit.apply(me, args);
            };
        }
        return Stream.prototype.on.call(me, ev, handler);
    };
    // character classes and tokens
    var whitespace = '\r\n\t ';
    // this really needs to be replaced with character classes.
    // XML allows all manner of ridiculous numbers and digits.
    var number = '0124356789';
    var letter = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
    // (Letter | "_" | ":")
    var quote = '\'"';
    var attribEnd = whitespace + '>';
    var CDATA = '[CDATA[';
    var DOCTYPE = 'DOCTYPE';
    var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';
    var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';
    var rootNS = {
        xml: XML_NAMESPACE,
        xmlns: XMLNS_NAMESPACE
    };
    // turn all the string character sets into character class objects.
    whitespace = charClass(whitespace);
    number = charClass(number);
    letter = charClass(letter);
    // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
    // This implementation works on strings, a single character at a time
    // as such, it cannot ever support astral-plane characters (10000-EFFFF)
    // without a significant breaking change to either this  parser, or the
    // JavaScript language.  Implementation of an emoji-capable xml parser
    // is left as an exercise for the reader.
    var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/;
    var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/;
    quote = charClass(quote);
    attribEnd = charClass(attribEnd);
    function charClass(str) {
        return str.split('').reduce(function(s, c) {
            s[c] = true;
            return s;
        }, {});
    }
    function isRegExp(c) {
        return Object.prototype.toString.call(c) === '[object RegExp]';
    }
    function is(charclass, c) {
        return isRegExp(charclass) ? !!c.match(charclass) : charclass[c];
    }
    function not(charclass, c) {
        return !is(charclass, c);
    }
    var S = 0;
    sax.STATE = {
        BEGIN: S++,
        BEGIN_WHITESPACE: S++,
        TEXT: S++,
        TEXT_ENTITY: S++,
        OPEN_WAKA: S++,
        SGML_DECL: S++,
        SGML_DECL_QUOTED: S++,
        DOCTYPE: S++,
        DOCTYPE_QUOTED: S++,
        DOCTYPE_DTD: S++,
        DOCTYPE_DTD_QUOTED: S++,
        COMMENT_STARTING: S++,
        COMMENT: S++,
        COMMENT_ENDING: S++,
        COMMENT_ENDED: S++,
        CDATA: S++,
        CDATA_ENDING: S++,
        CDATA_ENDING_2: S++,
        PROC_INST: S++,
        PROC_INST_BODY: S++,
        PROC_INST_ENDING: S++,
        OPEN_TAG: S++,
        OPEN_TAG_SLASH: S++,
        ATTRIB: S++,
        ATTRIB_NAME: S++,
        ATTRIB_NAME_SAW_WHITE: S++,
        ATTRIB_VALUE: S++,
        ATTRIB_VALUE_QUOTED: S++,
        ATTRIB_VALUE_CLOSED: S++,
        ATTRIB_VALUE_UNQUOTED: S++,
        ATTRIB_VALUE_ENTITY_Q: S++,
        ATTRIB_VALUE_ENTITY_U: S++,
        CLOSE_TAG: S++,
        CLOSE_TAG_SAW_WHITE: S++,
        SCRIPT: S++,
        SCRIPT_ENDING: S++ // <script> ... <
    };
    sax.XML_ENTITIES = {
        'amp': '&',
        'gt': '>',
        'lt': '<',
        'quot': '"',
        'apos': "'"
    };
    sax.ENTITIES = {
        'amp': '&',
        'gt': '>',
        'lt': '<',
        'quot': '"',
        'apos': "'",
        'AElig': 198,
        'Aacute': 193,
        'Acirc': 194,
        'Agrave': 192,
        'Aring': 197,
        'Atilde': 195,
        'Auml': 196,
        'Ccedil': 199,
        'ETH': 208,
        'Eacute': 201,
        'Ecirc': 202,
        'Egrave': 200,
        'Euml': 203,
        'Iacute': 205,
        'Icirc': 206,
        'Igrave': 204,
        'Iuml': 207,
        'Ntilde': 209,
        'Oacute': 211,
        'Ocirc': 212,
        'Ograve': 210,
        'Oslash': 216,
        'Otilde': 213,
        'Ouml': 214,
        'THORN': 222,
        'Uacute': 218,
        'Ucirc': 219,
        'Ugrave': 217,
        'Uuml': 220,
        'Yacute': 221,
        'aacute': 225,
        'acirc': 226,
        'aelig': 230,
        'agrave': 224,
        'aring': 229,
        'atilde': 227,
        'auml': 228,
        'ccedil': 231,
        'eacute': 233,
        'ecirc': 234,
        'egrave': 232,
        'eth': 240,
        'euml': 235,
        'iacute': 237,
        'icirc': 238,
        'igrave': 236,
        'iuml': 239,
        'ntilde': 241,
        'oacute': 243,
        'ocirc': 244,
        'ograve': 242,
        'oslash': 248,
        'otilde': 245,
        'ouml': 246,
        'szlig': 223,
        'thorn': 254,
        'uacute': 250,
        'ucirc': 251,
        'ugrave': 249,
        'uuml': 252,
        'yacute': 253,
        'yuml': 255,
        'copy': 169,
        'reg': 174,
        'nbsp': 160,
        'iexcl': 161,
        'cent': 162,
        'pound': 163,
        'curren': 164,
        'yen': 165,
        'brvbar': 166,
        'sect': 167,
        'uml': 168,
        'ordf': 170,
        'laquo': 171,
        'not': 172,
        'shy': 173,
        'macr': 175,
        'deg': 176,
        'plusmn': 177,
        'sup1': 185,
        'sup2': 178,
        'sup3': 179,
        'acute': 180,
        'micro': 181,
        'para': 182,
        'middot': 183,
        'cedil': 184,
        'ordm': 186,
        'raquo': 187,
        'frac14': 188,
        'frac12': 189,
        'frac34': 190,
        'iquest': 191,
        'times': 215,
        'divide': 247,
        'OElig': 338,
        'oelig': 339,
        'Scaron': 352,
        'scaron': 353,
        'Yuml': 376,
        'fnof': 402,
        'circ': 710,
        'tilde': 732,
        'Alpha': 913,
        'Beta': 914,
        'Gamma': 915,
        'Delta': 916,
        'Epsilon': 917,
        'Zeta': 918,
        'Eta': 919,
        'Theta': 920,
        'Iota': 921,
        'Kappa': 922,
        'Lambda': 923,
        'Mu': 924,
        'Nu': 925,
        'Xi': 926,
        'Omicron': 927,
        'Pi': 928,
        'Rho': 929,
        'Sigma': 931,
        'Tau': 932,
        'Upsilon': 933,
        'Phi': 934,
        'Chi': 935,
        'Psi': 936,
        'Omega': 937,
        'alpha': 945,
        'beta': 946,
        'gamma': 947,
        'delta': 948,
        'epsilon': 949,
        'zeta': 950,
        'eta': 951,
        'theta': 952,
        'iota': 953,
        'kappa': 954,
        'lambda': 955,
        'mu': 956,
        'nu': 957,
        'xi': 958,
        'omicron': 959,
        'pi': 960,
        'rho': 961,
        'sigmaf': 962,
        'sigma': 963,
        'tau': 964,
        'upsilon': 965,
        'phi': 966,
        'chi': 967,
        'psi': 968,
        'omega': 969,
        'thetasym': 977,
        'upsih': 978,
        'piv': 982,
        'ensp': 8194,
        'emsp': 8195,
        'thinsp': 8201,
        'zwnj': 8204,
        'zwj': 8205,
        'lrm': 8206,
        'rlm': 8207,
        'ndash': 8211,
        'mdash': 8212,
        'lsquo': 8216,
        'rsquo': 8217,
        'sbquo': 8218,
        'ldquo': 8220,
        'rdquo': 8221,
        'bdquo': 8222,
        'dagger': 8224,
        'Dagger': 8225,
        'bull': 8226,
        'hellip': 8230,
        'permil': 8240,
        'prime': 8242,
        'Prime': 8243,
        'lsaquo': 8249,
        'rsaquo': 8250,
        'oline': 8254,
        'frasl': 8260,
        'euro': 8364,
        'image': 8465,
        'weierp': 8472,
        'real': 8476,
        'trade': 8482,
        'alefsym': 8501,
        'larr': 8592,
        'uarr': 8593,
        'rarr': 8594,
        'darr': 8595,
        'harr': 8596,
        'crarr': 8629,
        'lArr': 8656,
        'uArr': 8657,
        'rArr': 8658,
        'dArr': 8659,
        'hArr': 8660,
        'forall': 8704,
        'part': 8706,
        'exist': 8707,
        'empty': 8709,
        'nabla': 8711,
        'isin': 8712,
        'notin': 8713,
        'ni': 8715,
        'prod': 8719,
        'sum': 8721,
        'minus': 8722,
        'lowast': 8727,
        'radic': 8730,
        'prop': 8733,
        'infin': 8734,
        'ang': 8736,
        'and': 8743,
        'or': 8744,
        'cap': 8745,
        'cup': 8746,
        'int': 8747,
        'there4': 8756,
        'sim': 8764,
        'cong': 8773,
        'asymp': 8776,
        'ne': 8800,
        'equiv': 8801,
        'le': 8804,
        'ge': 8805,
        'sub': 8834,
        'sup': 8835,
        'nsub': 8836,
        'sube': 8838,
        'supe': 8839,
        'oplus': 8853,
        'otimes': 8855,
        'perp': 8869,
        'sdot': 8901,
        'lceil': 8968,
        'rceil': 8969,
        'lfloor': 8970,
        'rfloor': 8971,
        'lang': 9001,
        'rang': 9002,
        'loz': 9674,
        'spades': 9824,
        'clubs': 9827,
        'hearts': 9829,
        'diams': 9830
    };
    Object.keys(sax.ENTITIES).forEach(function(key) {
        var e = sax.ENTITIES[key];
        var s = typeof e === 'number' ? String.fromCharCode(e) : e;
        sax.ENTITIES[key] = s;
    });
    for(var s in sax.STATE){
        sax.STATE[sax.STATE[s]] = s;
    }
    // shorthand
    S = sax.STATE;
    function emit(parser, event, data) {
        parser[event] && parser[event](data);
    }
    function emitNode(parser, nodeType, data) {
        if (parser.textNode) closeText(parser);
        emit(parser, nodeType, data);
    }
    function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode) emit(parser, 'ontext', parser.textNode);
        parser.textNode = '';
    }
    function textopts(opt, text) {
        if (opt.trim) text = text.trim();
        if (opt.normalize) text = text.replace(/\s+/g, ' ');
        return text;
    }
    function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
            er += '\nLine: ' + parser.line + '\nColumn: ' + parser.column + '\nChar: ' + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit(parser, 'onerror', er);
        return parser;
    }
    function end(parser) {
        if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag');
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
            error(parser, 'Unexpected end');
        }
        closeText(parser);
        parser.c = '';
        parser.closed = true;
        emit(parser, 'onend');
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
    }
    function strictFail(parser, message) {
        if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
            throw new Error('bad call to strictFail');
        }
        if (parser.strict) {
            error(parser, message);
        }
    }
    function newTag(parser) {
        if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = {
            name: parser.tagName,
            attributes: {}
        };
        // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
        if (parser.opt.xmlns) {
            tag.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, 'onopentagstart', tag);
    }
    function qname(name, attribute) {
        var i = name.indexOf(':');
        var qualName = i < 0 ? [
            '',
            name
        ] : name.split(':');
        var prefix = qualName[0];
        var local = qualName[1];
        // <x "xmlns"="http://foo">
        if (attribute && name === 'xmlns') {
            prefix = 'xmlns';
            local = '';
        }
        return {
            prefix: prefix,
            local: local
        };
    }
    function attrib(parser) {
        if (!parser.strict) {
            parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
            parser.attribName = parser.attribValue = '';
            return;
        }
        if (parser.opt.xmlns) {
            var qn = qname(parser.attribName, true);
            var prefix = qn.prefix;
            var local = qn.local;
            if (prefix === 'xmlns') {
                // namespace binding attribute. push the binding into scope
                if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
                    strictFail(parser, 'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' + 'Actual: ' + parser.attribValue);
                } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
                    strictFail(parser, 'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' + 'Actual: ' + parser.attribValue);
                } else {
                    var tag = parser.tag;
                    var parent = parser.tags[parser.tags.length - 1] || parser;
                    if (tag.ns === parent.ns) {
                        tag.ns = Object.create(parent.ns);
                    }
                    tag.ns[local] = parser.attribValue;
                }
            }
            // defer onattribute events until all attributes have been seen
            // so any new bindings can take effect. preserve attribute order
            // so deferred events can be emitted in document order
            parser.attribList.push([
                parser.attribName,
                parser.attribValue
            ]);
        } else {
            // in non-xmlns mode, we can emit the event right away
            parser.tag.attributes[parser.attribName] = parser.attribValue;
            emitNode(parser, 'onattribute', {
                name: parser.attribName,
                value: parser.attribValue
            });
        }
        parser.attribName = parser.attribValue = '';
    }
    function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
            // emit namespace binding events
            var tag = parser.tag;
            // add namespace info to tag
            var qn = qname(parser.tagName);
            tag.prefix = qn.prefix;
            tag.local = qn.local;
            tag.uri = tag.ns[qn.prefix] || '';
            if (tag.prefix && !tag.uri) {
                strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(parser.tagName));
                tag.uri = qn.prefix;
            }
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns && parent.ns !== tag.ns) {
                Object.keys(tag.ns).forEach(function(p) {
                    emitNode(parser, 'onopennamespace', {
                        prefix: p,
                        uri: tag.ns[p]
                    });
                });
            }
            // handle deferred onattribute events
            // Note: do not apply default ns to attributes:
            //   http://www.w3.org/TR/REC-xml-names/#defaulting
            for(var i = 0, l = parser.attribList.length; i < l; i++){
                var nv = parser.attribList[i];
                var name = nv[0];
                var value = nv[1];
                var qualName = qname(name, true);
                var prefix = qualName.prefix;
                var local = qualName.local;
                var uri = prefix === '' ? '' : tag.ns[prefix] || '';
                var a = {
                    name: name,
                    value: value,
                    prefix: prefix,
                    local: local,
                    uri: uri
                };
                // if there's any attributes with an undefined namespace,
                // then fail on them now.
                if (prefix && prefix !== 'xmlns' && !uri) {
                    strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(prefix));
                    a.uri = prefix;
                }
                parser.tag.attributes[name] = a;
                emitNode(parser, 'onattribute', a);
            }
            parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        // process the tag
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, 'onopentag', parser.tag);
        if (!selfClosing) {
            // special case for <script> in non-strict mode.
            if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
                parser.state = S.SCRIPT;
            } else {
                parser.state = S.TEXT;
            }
            parser.tag = null;
            parser.tagName = '';
        }
        parser.attribName = parser.attribValue = '';
        parser.attribList.length = 0;
    }
    function closeTag(parser) {
        if (!parser.tagName) {
            strictFail(parser, 'Weird empty close tag.');
            parser.textNode += '</>';
            parser.state = S.TEXT;
            return;
        }
        if (parser.script) {
            if (parser.tagName !== 'script') {
                parser.script += '</' + parser.tagName + '>';
                parser.tagName = '';
                parser.state = S.SCRIPT;
                return;
            }
            emitNode(parser, 'onscript', parser.script);
            parser.script = '';
        }
        // first make sure that the closing tag actually exists.
        // <a><b></c></b></a> will close everything, otherwise.
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
            tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while(t--){
            var close = parser.tags[t];
            if (close.name !== closeTo) {
                // fail the first time in strict mode
                strictFail(parser, 'Unexpected close tag');
            } else {
                break;
            }
        }
        // didn't find it.  we already failed for strict, so just abort.
        if (t < 0) {
            strictFail(parser, 'Unmatched closing tag: ' + parser.tagName);
            parser.textNode += '</' + parser.tagName + '>';
            parser.state = S.TEXT;
            return;
        }
        parser.tagName = tagName;
        var s = parser.tags.length;
        while(s-- > t){
            var tag = parser.tag = parser.tags.pop();
            parser.tagName = parser.tag.name;
            emitNode(parser, 'onclosetag', parser.tagName);
            var x = {};
            for(var i in tag.ns){
                x[i] = tag.ns[i];
            }
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (parser.opt.xmlns && tag.ns !== parent.ns) {
                // remove namespace bindings introduced by tag
                Object.keys(tag.ns).forEach(function(p) {
                    var n = tag.ns[p];
                    emitNode(parser, 'onclosenamespace', {
                        prefix: p,
                        uri: n
                    });
                });
            }
        }
        if (t === 0) parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = '';
        parser.attribList.length = 0;
        parser.state = S.TEXT;
    }
    function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = '';
        if (parser.ENTITIES[entity]) {
            return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
            return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === '#') {
            if (entity.charAt(1) === 'x') {
                entity = entity.slice(2);
                num = parseInt(entity, 16);
                numStr = num.toString(16);
            } else {
                entity = entity.slice(1);
                num = parseInt(entity, 10);
                numStr = num.toString(10);
            }
        }
        entity = entity.replace(/^0+/, '');
        if (numStr.toLowerCase() !== entity) {
            strictFail(parser, 'Invalid character entity');
            return '&' + parser.entity + ';';
        }
        return String.fromCodePoint(num);
    }
    function beginWhiteSpace(parser, c) {
        if (c === '<') {
            parser.state = S.OPEN_WAKA;
            parser.startTagPosition = parser.position;
        } else if (not(whitespace, c)) {
            // have to process this as a text node.
            // weird, but happens.
            strictFail(parser, 'Non-whitespace before first tag.');
            parser.textNode = c;
            parser.state = S.TEXT;
        }
    }
    function charAt(chunk, i) {
        var result = '';
        if (i < chunk.length) {
            result = chunk.charAt(i);
        }
        return result;
    }
    function write(chunk) {
        var parser = this;
        if (this.error) {
            throw this.error;
        }
        if (parser.closed) {
            return error(parser, 'Cannot write after close. Assign an onready handler.');
        }
        if (chunk === null) {
            return end(parser);
        }
        if (typeof chunk === 'object') {
            chunk = chunk.toString();
        }
        var i = 0;
        var c = '';
        while(true){
            c = charAt(chunk, i++);
            parser.c = c;
            if (!c) {
                break;
            }
            if (parser.trackPosition) {
                parser.position++;
                if (c === '\n') {
                    parser.line++;
                    parser.column = 0;
                } else {
                    parser.column++;
                }
            }
            switch(parser.state){
                case S.BEGIN:
                    parser.state = S.BEGIN_WHITESPACE;
                    if (c === '\uFEFF') {
                        continue;
                    }
                    beginWhiteSpace(parser, c);
                    continue;
                case S.BEGIN_WHITESPACE:
                    beginWhiteSpace(parser, c);
                    continue;
                case S.TEXT:
                    if (parser.sawRoot && !parser.closedRoot) {
                        var starti = i - 1;
                        while(c && c !== '<' && c !== '&'){
                            c = charAt(chunk, i++);
                            if (c && parser.trackPosition) {
                                parser.position++;
                                if (c === '\n') {
                                    parser.line++;
                                    parser.column = 0;
                                } else {
                                    parser.column++;
                                }
                            }
                        }
                        parser.textNode += chunk.substring(starti, i - 1);
                    }
                    if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                        parser.state = S.OPEN_WAKA;
                        parser.startTagPosition = parser.position;
                    } else {
                        if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot)) {
                            strictFail(parser, 'Text data outside of root node.');
                        }
                        if (c === '&') {
                            parser.state = S.TEXT_ENTITY;
                        } else {
                            parser.textNode += c;
                        }
                    }
                    continue;
                case S.SCRIPT:
                    // only non-strict
                    if (c === '<') {
                        parser.state = S.SCRIPT_ENDING;
                    } else {
                        parser.script += c;
                    }
                    continue;
                case S.SCRIPT_ENDING:
                    if (c === '/') {
                        parser.state = S.CLOSE_TAG;
                    } else {
                        parser.script += '<' + c;
                        parser.state = S.SCRIPT;
                    }
                    continue;
                case S.OPEN_WAKA:
                    // either a /, ?, !, or text is coming next.
                    if (c === '!') {
                        parser.state = S.SGML_DECL;
                        parser.sgmlDecl = '';
                    } else if (is(whitespace, c)) {
                    // wait for it...
                    } else if (is(nameStart, c)) {
                        parser.state = S.OPEN_TAG;
                        parser.tagName = c;
                    } else if (c === '/') {
                        parser.state = S.CLOSE_TAG;
                        parser.tagName = '';
                    } else if (c === '?') {
                        parser.state = S.PROC_INST;
                        parser.procInstName = parser.procInstBody = '';
                    } else {
                        strictFail(parser, 'Unencoded <');
                        // if there was some whitespace, then add that in.
                        if (parser.startTagPosition + 1 < parser.position) {
                            var pad = parser.position - parser.startTagPosition;
                            c = new Array(pad).join(' ') + c;
                        }
                        parser.textNode += '<' + c;
                        parser.state = S.TEXT;
                    }
                    continue;
                case S.SGML_DECL:
                    if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                        emitNode(parser, 'onopencdata');
                        parser.state = S.CDATA;
                        parser.sgmlDecl = '';
                        parser.cdata = '';
                    } else if (parser.sgmlDecl + c === '--') {
                        parser.state = S.COMMENT;
                        parser.comment = '';
                        parser.sgmlDecl = '';
                    } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                        parser.state = S.DOCTYPE;
                        if (parser.doctype || parser.sawRoot) {
                            strictFail(parser, 'Inappropriately located doctype declaration');
                        }
                        parser.doctype = '';
                        parser.sgmlDecl = '';
                    } else if (c === '>') {
                        emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl);
                        parser.sgmlDecl = '';
                        parser.state = S.TEXT;
                    } else if (is(quote, c)) {
                        parser.state = S.SGML_DECL_QUOTED;
                        parser.sgmlDecl += c;
                    } else {
                        parser.sgmlDecl += c;
                    }
                    continue;
                case S.SGML_DECL_QUOTED:
                    if (c === parser.q) {
                        parser.state = S.SGML_DECL;
                        parser.q = '';
                    }
                    parser.sgmlDecl += c;
                    continue;
                case S.DOCTYPE:
                    if (c === '>') {
                        parser.state = S.TEXT;
                        emitNode(parser, 'ondoctype', parser.doctype);
                        parser.doctype = true // just remember that we saw it.
                        ;
                    } else {
                        parser.doctype += c;
                        if (c === '[') {
                            parser.state = S.DOCTYPE_DTD;
                        } else if (is(quote, c)) {
                            parser.state = S.DOCTYPE_QUOTED;
                            parser.q = c;
                        }
                    }
                    continue;
                case S.DOCTYPE_QUOTED:
                    parser.doctype += c;
                    if (c === parser.q) {
                        parser.q = '';
                        parser.state = S.DOCTYPE;
                    }
                    continue;
                case S.DOCTYPE_DTD:
                    parser.doctype += c;
                    if (c === ']') {
                        parser.state = S.DOCTYPE;
                    } else if (is(quote, c)) {
                        parser.state = S.DOCTYPE_DTD_QUOTED;
                        parser.q = c;
                    }
                    continue;
                case S.DOCTYPE_DTD_QUOTED:
                    parser.doctype += c;
                    if (c === parser.q) {
                        parser.state = S.DOCTYPE_DTD;
                        parser.q = '';
                    }
                    continue;
                case S.COMMENT:
                    if (c === '-') {
                        parser.state = S.COMMENT_ENDING;
                    } else {
                        parser.comment += c;
                    }
                    continue;
                case S.COMMENT_ENDING:
                    if (c === '-') {
                        parser.state = S.COMMENT_ENDED;
                        parser.comment = textopts(parser.opt, parser.comment);
                        if (parser.comment) {
                            emitNode(parser, 'oncomment', parser.comment);
                        }
                        parser.comment = '';
                    } else {
                        parser.comment += '-' + c;
                        parser.state = S.COMMENT;
                    }
                    continue;
                case S.COMMENT_ENDED:
                    if (c !== '>') {
                        strictFail(parser, 'Malformed comment');
                        // allow <!-- blah -- bloo --> in non-strict mode,
                        // which is a comment of " blah -- bloo "
                        parser.comment += '--' + c;
                        parser.state = S.COMMENT;
                    } else {
                        parser.state = S.TEXT;
                    }
                    continue;
                case S.CDATA:
                    if (c === ']') {
                        parser.state = S.CDATA_ENDING;
                    } else {
                        parser.cdata += c;
                    }
                    continue;
                case S.CDATA_ENDING:
                    if (c === ']') {
                        parser.state = S.CDATA_ENDING_2;
                    } else {
                        parser.cdata += ']' + c;
                        parser.state = S.CDATA;
                    }
                    continue;
                case S.CDATA_ENDING_2:
                    if (c === '>') {
                        if (parser.cdata) {
                            emitNode(parser, 'oncdata', parser.cdata);
                        }
                        emitNode(parser, 'onclosecdata');
                        parser.cdata = '';
                        parser.state = S.TEXT;
                    } else if (c === ']') {
                        parser.cdata += ']';
                    } else {
                        parser.cdata += ']]' + c;
                        parser.state = S.CDATA;
                    }
                    continue;
                case S.PROC_INST:
                    if (c === '?') {
                        parser.state = S.PROC_INST_ENDING;
                    } else if (is(whitespace, c)) {
                        parser.state = S.PROC_INST_BODY;
                    } else {
                        parser.procInstName += c;
                    }
                    continue;
                case S.PROC_INST_BODY:
                    if (!parser.procInstBody && is(whitespace, c)) {
                        continue;
                    } else if (c === '?') {
                        parser.state = S.PROC_INST_ENDING;
                    } else {
                        parser.procInstBody += c;
                    }
                    continue;
                case S.PROC_INST_ENDING:
                    if (c === '>') {
                        emitNode(parser, 'onprocessinginstruction', {
                            name: parser.procInstName,
                            body: parser.procInstBody
                        });
                        parser.procInstName = parser.procInstBody = '';
                        parser.state = S.TEXT;
                    } else {
                        parser.procInstBody += '?' + c;
                        parser.state = S.PROC_INST_BODY;
                    }
                    continue;
                case S.OPEN_TAG:
                    if (is(nameBody, c)) {
                        parser.tagName += c;
                    } else {
                        newTag(parser);
                        if (c === '>') {
                            openTag(parser);
                        } else if (c === '/') {
                            parser.state = S.OPEN_TAG_SLASH;
                        } else {
                            if (not(whitespace, c)) {
                                strictFail(parser, 'Invalid character in tag name');
                            }
                            parser.state = S.ATTRIB;
                        }
                    }
                    continue;
                case S.OPEN_TAG_SLASH:
                    if (c === '>') {
                        openTag(parser, true);
                        closeTag(parser);
                    } else {
                        strictFail(parser, 'Forward-slash in opening tag not followed by >');
                        parser.state = S.ATTRIB;
                    }
                    continue;
                case S.ATTRIB:
                    // haven't read the attribute name yet.
                    if (is(whitespace, c)) {
                        continue;
                    } else if (c === '>') {
                        openTag(parser);
                    } else if (c === '/') {
                        parser.state = S.OPEN_TAG_SLASH;
                    } else if (is(nameStart, c)) {
                        parser.attribName = c;
                        parser.attribValue = '';
                        parser.state = S.ATTRIB_NAME;
                    } else {
                        strictFail(parser, 'Invalid attribute name');
                    }
                    continue;
                case S.ATTRIB_NAME:
                    if (c === '=') {
                        parser.state = S.ATTRIB_VALUE;
                    } else if (c === '>') {
                        strictFail(parser, 'Attribute without value');
                        parser.attribValue = parser.attribName;
                        attrib(parser);
                        openTag(parser);
                    } else if (is(whitespace, c)) {
                        parser.state = S.ATTRIB_NAME_SAW_WHITE;
                    } else if (is(nameBody, c)) {
                        parser.attribName += c;
                    } else {
                        strictFail(parser, 'Invalid attribute name');
                    }
                    continue;
                case S.ATTRIB_NAME_SAW_WHITE:
                    if (c === '=') {
                        parser.state = S.ATTRIB_VALUE;
                    } else if (is(whitespace, c)) {
                        continue;
                    } else {
                        strictFail(parser, 'Attribute without value');
                        parser.tag.attributes[parser.attribName] = '';
                        parser.attribValue = '';
                        emitNode(parser, 'onattribute', {
                            name: parser.attribName,
                            value: ''
                        });
                        parser.attribName = '';
                        if (c === '>') {
                            openTag(parser);
                        } else if (is(nameStart, c)) {
                            parser.attribName = c;
                            parser.state = S.ATTRIB_NAME;
                        } else {
                            strictFail(parser, 'Invalid attribute name');
                            parser.state = S.ATTRIB;
                        }
                    }
                    continue;
                case S.ATTRIB_VALUE:
                    if (is(whitespace, c)) {
                        continue;
                    } else if (is(quote, c)) {
                        parser.q = c;
                        parser.state = S.ATTRIB_VALUE_QUOTED;
                    } else {
                        strictFail(parser, 'Unquoted attribute value');
                        parser.state = S.ATTRIB_VALUE_UNQUOTED;
                        parser.attribValue = c;
                    }
                    continue;
                case S.ATTRIB_VALUE_QUOTED:
                    if (c !== parser.q) {
                        if (c === '&') {
                            parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                        } else {
                            parser.attribValue += c;
                        }
                        continue;
                    }
                    attrib(parser);
                    parser.q = '';
                    parser.state = S.ATTRIB_VALUE_CLOSED;
                    continue;
                case S.ATTRIB_VALUE_CLOSED:
                    if (is(whitespace, c)) {
                        parser.state = S.ATTRIB;
                    } else if (c === '>') {
                        openTag(parser);
                    } else if (c === '/') {
                        parser.state = S.OPEN_TAG_SLASH;
                    } else if (is(nameStart, c)) {
                        strictFail(parser, 'No whitespace between attributes');
                        parser.attribName = c;
                        parser.attribValue = '';
                        parser.state = S.ATTRIB_NAME;
                    } else {
                        strictFail(parser, 'Invalid attribute name');
                    }
                    continue;
                case S.ATTRIB_VALUE_UNQUOTED:
                    if (not(attribEnd, c)) {
                        if (c === '&') {
                            parser.state = S.ATTRIB_VALUE_ENTITY_U;
                        } else {
                            parser.attribValue += c;
                        }
                        continue;
                    }
                    attrib(parser);
                    if (c === '>') {
                        openTag(parser);
                    } else {
                        parser.state = S.ATTRIB;
                    }
                    continue;
                case S.CLOSE_TAG:
                    if (!parser.tagName) {
                        if (is(whitespace, c)) {
                            continue;
                        } else if (not(nameStart, c)) {
                            if (parser.script) {
                                parser.script += '</' + c;
                                parser.state = S.SCRIPT;
                            } else {
                                strictFail(parser, 'Invalid tagname in closing tag.');
                            }
                        } else {
                            parser.tagName = c;
                        }
                    } else if (c === '>') {
                        closeTag(parser);
                    } else if (is(nameBody, c)) {
                        parser.tagName += c;
                    } else if (parser.script) {
                        parser.script += '</' + parser.tagName;
                        parser.tagName = '';
                        parser.state = S.SCRIPT;
                    } else {
                        if (not(whitespace, c)) {
                            strictFail(parser, 'Invalid tagname in closing tag');
                        }
                        parser.state = S.CLOSE_TAG_SAW_WHITE;
                    }
                    continue;
                case S.CLOSE_TAG_SAW_WHITE:
                    if (is(whitespace, c)) {
                        continue;
                    }
                    if (c === '>') {
                        closeTag(parser);
                    } else {
                        strictFail(parser, 'Invalid characters in closing tag');
                    }
                    continue;
                case S.TEXT_ENTITY:
                case S.ATTRIB_VALUE_ENTITY_Q:
                case S.ATTRIB_VALUE_ENTITY_U:
                    var returnState;
                    var buffer;
                    switch(parser.state){
                        case S.TEXT_ENTITY:
                            returnState = S.TEXT;
                            buffer = 'textNode';
                            break;
                        case S.ATTRIB_VALUE_ENTITY_Q:
                            returnState = S.ATTRIB_VALUE_QUOTED;
                            buffer = 'attribValue';
                            break;
                        case S.ATTRIB_VALUE_ENTITY_U:
                            returnState = S.ATTRIB_VALUE_UNQUOTED;
                            buffer = 'attribValue';
                            break;
                    }
                    if (c === ';') {
                        parser[buffer] += parseEntity(parser);
                        parser.entity = '';
                        parser.state = returnState;
                    } else if (is(parser.entity.length ? entityBody : entityStart, c)) {
                        parser.entity += c;
                    } else {
                        strictFail(parser, 'Invalid character in entity name');
                        parser[buffer] += '&' + parser.entity + c;
                        parser.entity = '';
                        parser.state = returnState;
                    }
                    continue;
                default:
                    throw new Error(parser, 'Unknown state: ' + parser.state);
            }
        } // while
        if (parser.position >= parser.bufferCheckPosition) {
            checkBufferLength(parser);
        }
        return parser;
    }
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */ if (!String.fromCodePoint) {
        (function() {
            var stringFromCharCode = String.fromCharCode;
            var floor = Math.floor;
            var fromCodePoint = function() {
                var MAX_SIZE = 0x4000;
                var codeUnits = [];
                var highSurrogate;
                var lowSurrogate;
                var index = -1;
                var length = arguments.length;
                if (!length) {
                    return '';
                }
                var result = '';
                while(++index < length){
                    var codePoint = Number(arguments[index]);
                    if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                    codePoint < 0 || // not a valid Unicode code point
                    codePoint > 0x10FFFF || // not a valid Unicode code point
                    floor(codePoint) !== codePoint // not an integer
                    ) {
                        throw RangeError('Invalid code point: ' + codePoint);
                    }
                    if (codePoint <= 0xFFFF) {
                        codeUnits.push(codePoint);
                    } else {
                        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                        codePoint -= 0x10000;
                        highSurrogate = (codePoint >> 10) + 0xD800;
                        lowSurrogate = codePoint % 0x400 + 0xDC00;
                        codeUnits.push(highSurrogate, lowSurrogate);
                    }
                    if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                        result += stringFromCharCode.apply(null, codeUnits);
                        codeUnits.length = 0;
                    }
                }
                return result;
            };
            if (Object.defineProperty) {
                Object.defineProperty(String, 'fromCodePoint', {
                    value: fromCodePoint,
                    configurable: true,
                    writable: true
                });
            } else {
                String.fromCodePoint = fromCodePoint;
            }
        })();
    }
})(("TURBOPACK compile-time falsy", 0) ? ("TURBOPACK unreachable", undefined) : exports);
}}),

};

//# sourceMappingURL=node_modules_0517aa3c._.js.map